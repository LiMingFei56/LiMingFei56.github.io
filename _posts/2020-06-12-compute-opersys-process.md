---
layout: post
title: "操作系统-进程"
categories: computer
tags: [opersys]
date: 2020-06-12
excerpt: "操作系统-进程"
---

## 操作系统-进程

> 一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程.

进程的组成
* 程序的代码
* 程序处理的数据
* 程序计数器中的值, 指示下一条将运行的指令
* 一组通用的寄存器的当前值, 堆, 栈
* 一组系统资源(如打开的文件)
* 进程包含了正在运行的一个程序的所有状态信息

进程与程序的联系
* 程序是产生进程的基础
* 程序的每次运行构成不同的进程
* 进程是程序功能的体现
* 通过多次执行, 一个程序可对应多个进程; 通过调用关系, 一个进程可包括外个程序.

进程与程序的区别
* 进程是动态的, 程序是静态的
* 进程是程序的执行, 进程有核心态/用户态
* 进程是暂时的, 程序是永久的: 进程是一个状态变化的过程, 程序可长久保存
* 进程与程序的组成不同: 进程的组成包括程序\数据和进程控制块(即进程状态信息)

并发和并行
* 并发: 在一段时间内有多个进程在执行
* 并行: 在一个时刻有多个进程在执行

特点:
* 动态性
* 并发性
* 独立性
* 制约性

### 进程控制

`进程控制块`(Process Control Block, PCB). 操作系统为每个进程都维护一个PCB, 用来保存  
与该进程有关的各种状态信息, 是进程存在的唯一标识.

进程标识信息: 本进程的标识PID, 本进程的产生者标识PPID, 用户标识UID.
处理机状态信息保存区: 用户可见寄存器, 控制和状态寄存器, 栈指针.
进程控制信息: 调度和状态信息, 进程间通信信息, 存储管理信息, 进程所用资源, 有关数据结构
    连接信息

PCB使用链表组织, 同一状态的进程其PCB成一链表, 外个状态对应多个不同的链表. 因为进程的
状态是动态变化的, 使用链表方便删除和添加状态. 如果操作系统有特殊作用, 也可以使用索引
表.

### 进程状态

#### 进程生命期

* 进程创建 1: 初始进程; 2: 用户启动; 3: 程序启动
* 进程运行 选择就绪进程
* 进程等待 自身触发
* 进程唤醒 等待事件得到满足
* 进程结束 1: 正常退出; 2: 错误退出; 3: 致命错误; 4: 被其他进程所杀

基本状态
1: 就绪态
2: 运行态
3: 等待态

4: 创建态
5: 结束态

#### 进程挂起

进程没有占用内存空间. 

阻塞挂起状态(blocked suspend): 进程在外存并等待某事件的出现
就绪挂起状态(ready suspend): 进程在外存, 但只要进入内存即运行

选择挂起进程:
在内存
1. 阻塞到阻塞挂起
2. 就绪到就绪挂起
3. 运行到就绪挂起
在外存
4. 阻塞挂起到就绪挂起

状态队列: 每种状态都有一个队列. 挂起队列(notify) 如果一个事件只满足一个进程
, 那么只改变一个进程的状态.(notify_all)如果一个事件满足队列中的所有进程
, 那么改变所有进程的状态

### 线程

进程间如果需要紧密的协同工作, 那么1: 进程之间如何通信? 2: 维护进程的系统开销较大
(创建, 撤消, 切换)

线程: 1: 实体之间可以并发执行; 2: 实体之间共享相同的地址空间.

线程是进程当中的一条执行流程. 进程用来管理资源, 把执行过程交给线程.

线程控制块 thread control blocl, 线程有独立资源和共享资源

线程开销:
* 线程创建不用创建资源相关的内容, 进程已经创建
* 线程终止不用释放资源相关的内容
* 线程切换不用切换页表
* 线程不用通过内核通信

线程的种类:
1. 用户线程(协程): 程序控制调度的执行单元
2. 内核线程: 操作系统控制调度的执行单元
3. 轻量级进程: 在内核中实现, 支持用户线程. 

上下文切换使用汇编来实现

### 进程优化

1. fork vfork
2. copy-on-write

僵尸状态: 子进程exit()后, 资源释放, 但是PCD没有被释放, 等待被释放的状态.

### 调度

上下文切换:
    * 切换CPU的当前任务, 从一个进程/线程到另一个
    * 保存当前进程/线程在PCB/TCP中的执行上下文(CPU状态)
    * 读取下一个进程/线程的上下文

CPU调度:
    * 从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程
    * 调度程序: 挑选进程/线程的内核函数(通过一些调度策略)
    * 什么时候进行调度?

内核运行调度程序的条件(满足一条即可)
    * 一个进程从运行状态切换到等待状态
    * 一个进程被终结了

不可抢占:
    * 调度程序必须等待事件结束

可以抢占:
    * 调度程序在中断被响应后执行
    * 当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪
    * 当前运行的进程可以被换出

> 调度与抢占, 分为用户态和内核态, 如果一个进程发起系统调用, 而且这个系统调用不会  
> 进入到阻塞状态, 那么这个进程不会被抢占.

#### 调度原则

执行模型: 程序在CPU突发和I/O中交替
    * 每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU
    * 在时间分片机制下, 线程可能在结束当前CPU突发前被迫放弃CPU

指标:
* CPU使用率
* 吞吐量
* 周转时间
* 等待时间
* 响应时间

目标:
* 减少响应时间
* 减少平均响应时间的波动
* 增加吞吐量
* 减少等待时间
* 公平

#### 调度算法
* FCFS - 先来先服务, 长时间任务先执行, 会导致整体周围时间过长
* SPN SJF SRT - 短进程优先, 长任务饥饿, 需要估计执行时间
* HRRN - 最高响应比优先, 考虑了等待时间, 处理了长任务饥饿, 需要估计执行时间
* Round Robin - 轮循, 根据时间片轮流占用CPU, 过多的上下文切换
* Multilevel Feedback queues 多级反馈队列, 对进程进行分类选择不同算法, 进程是动  
    态的需要动态调整级别
* Fair Share Scheduling 公平共享调度, 对用户的级别实现公平调度

[Linux CFS Scheduler: Completely Fair Scheduler](https://www.kernel.org/doc/html/latest/scheduler/sched-design-CFS.html)

#### 实时调度

> realtime, 确保在规定的时间内完成任务. 强实时, 任务非常重要, 必须完成; 弱实时, 尽量  
> 完成.
> `时间约束的及时性(deadlines)`
> `任务(工作单元)`, 一次计算, 一次文件读取, 一次信息传递等等.

静态优先级调度: 运行前确定优先级 RM(Rate Monotonic)
动态优先级调度: 运行中动态改变优先级 EDF(Earliest Deadline First)

#### 多处理器调度

考虑的问题:
1. 选择哪个CPU处理
2. 负载均衡

#### 优先级反转

> 高优先级任务, 依赖低优先级的运行结果. 导致优先级反转

解决:
1. 优先级继承
2. 优先级天花板: "资源"的优先级和所有可以锁定该资源的任务中优先级最高的那个任务的优先  
    级相同.


