---
layout: post
title: "Swift"
categories: pl
tags: [pl]
date: 2022-05-17
---

## Swift

### ä½œç”¨åŸŸ

* global scope

### å˜é‡å’Œå¸¸é‡

		// å®šä¹‰å˜é‡å’Œå¸¸é‡, è‡ªåŠ¨æ¨å¯¼ç±»å‹
		var myVariable = 42
		let myConstant = 42
		
		// æŒ‡å®šç±»å‹
		let implicitInteger = 70
		let implicitDouble = 70.0
		let explicitDouble: Double = 70

		// ä¸æ”¯æŒéšå¼ç±»å‹è½¬æ¢, éœ€è¦æ˜¾ç¤ºè½¬æ¢
		let label = "The width is "
		let width = 94
		let widthLabel = label + String(width)

		// ç±»å‹åé¢åŠ ä¸Š`?`, æ ‡è®°è¿™ä¸ªå€¼æ˜¯å¯é€‰çš„. å¯ä»¥åŒ…å«ä¸€ä¸ªå€¼æˆ–è€…nil
		var optionalString: String? = "Hello"

		var red, green, blue: Double
		var a = 1, b = 2, c = 3

		// æ”¯æŒUTF-8 æ ‡è¯†ç¬¦
		let ğŸ¶ğŸ® = "dogcow"
		let cat = "ğŸ±"; print(cat)

		// UInt8, Int8, Uint16, Int16, Uint32, Int32, UInt64, Int64
		// Int: 32ä½å¹³å°, é»˜è®¤Int32; 64ä½å¹³å°, é»˜è®¤Int64
		// UInt: 32ä½å¹³å°, é»˜è®¤UInt32; 64ä½å¹³å°, é»˜è®¤UInt64
		let minValue = UInt8.min  // minValue is equal to 0, and is of type UInt8
		let maxValue = UInt8.max  // maxValue is equal to 255, and is of type UInt8

		// Double 64ä½ é»˜è®¤, 15ä½å°æ•°
		// Float 32ä½, 6ä½å°æ•°
		var a = 0.1

		let decimalInteger = 17
		let binaryInteger = 0b10001       // 17 in binary notation
		let octalInteger = 0o21           // 17 in octal notation
		let hexadecimalInteger = 0x11     // 17 in hexadecimal notation

		let decimalDouble = 12.1875
		let exponentDouble = 1.21875e1
		let hexadecimalDouble = 0xC.3p0

		let paddedDouble = 000123.456
		let oneMillion = 1_000_000
		let justOverOneMillion = 1_000_000.000_000_1

		// Type Aliases
		typealias AudioSample = UInt16

		// Tuples
		let http404Error = (404, "Not Found") // compound
		let (statusCode, statusMessage) = http404Error // decompose
		let (justTheStatusCode, _) = http404Error
		print("The status code is \(http404Error.0)")
		print("The status message is \(http404Error.1)")
		let http200Status = (statusCode: 200, description: "OK")
		print("The status code is \(http200Status.statusCode)")

### æ“ä½œ

		// = ä¸ä¼šè¿”å›å€¼, åªæœ‰èµ‹å€¼æ“ä½œ. æ‰€ä»¥ä¸ä¼šä¸== å¼„æ··
		// 0..<10 [0, 10); 0...10 [0, 10]; names[2...] or names[...2] or names[..<2]
		// æ”¯æŒ ä¸€å…ƒ, äºŒå…ƒ, ä¸‰å…ƒæ“ä½œ

		// èµ‹å€¼
		let b = 10
		var a = 5
		a = b 
		let (x, y) = (1, 2)

		// ä¸€å…ƒ: +, -
		let b = -1
		// äºŒå…ƒ
		1 + 2
		5 - 3
		2 * 3
		10.0 / 2.5
		"hello, " + "world"
		9 % 4
		// å¤åˆèµ‹å€¼è¿ç®—ç¬¦
		var a = 1
		a += 2
		// ä¸‰å…ƒ
		a = bo ? a : b
		a = bo ? b

		// é€»è¾‘æ“ä½œ
		Equal to (a == b)
		Not equal to (a != b)
		Greater than (a > b)
		Less than (a < b)
		Greater than or equal to (a >= b)
		Less than or equal to (a <= b)
		Logical NOT (!a)
		Logical AND (a && b)
		Logical OR (a || b)

		// ä¸¤ä¸ªåŒé•¿åº¦, åŒç±»å‹çš„tuples å¯ä»¥æ¯”è¾ƒ. ä»å·¦åˆ°å³ ç›´åˆ°æ‰¾åˆ°ä¸ç›¸ç­‰çš„å€¼
		(1, "zebra") < (2, "apple")

		// Nil-Coalescing Operator ç©ºåˆå¹¶æ“ä½œ
		a = a ?? b ç›¸å½“äº a != nil ? a! : b


### ç±»å‹å®‰å…¨

		1. ä¸ä¼šéšåŒ¿è½¬æ¢, ç¼–è¯‘æ—¶ä¼šç±»å‹æ£€æŸ¥
		2. Optionals ç±»å‹, å½“ç±»å‹è½¬æ¢æ—¶è¿”å›å¯é€‰ç±»å‹

		let possibleNumber = "123"
		let convertedNumber = Int(possibleNumber)	

		if convertedNumber != nil {
				print("convertedNumber contains some integer value.")
		}

		if let constantName = someOptional {
				statements
		}

		let possibleString: String?  // å¯é€‰ç±»å‹
		let assumedString: String! // éšå¼è§£åŒ…, å½“ç¡®å®šå¯é€‰å€¼æœ‰å€¼, å¹¶ä¸”ä¸€ç›´ä¼šæœ‰å€¼

### å­—ç¬¦ä¸²

		// æ¨¡æ¿å­—ç¬¦ä¸²
		let apples = 3
		let oranges = 5
		let appleSummary = "I have \(apples) apples."
		let fruitSummary = "I have \(apples + oranges) pieces of fruit."

		// å¤šè¡Œå­—ç¬¦ä¸²
		let quotation = """
		I said "I have \(apples) apples."
		And then I said "I have \(apples + oranges) pieces of fruit."
		"""
		// å¤šè¡Œå­—ç¬¦ä¸², æœ‰å‰å¯¼ç©ºæ ¼ä¼šåœ¨å­—ç¬¦ä¸²ä¸­å¿½ç•¥, éå‰å¯¼ç©ºæ ¼ä¼šåŠ åˆ°å­—ç¬¦ä¸²

		// ç‰¹æ®Šå­—ç¬¦ä½¿ç”¨`\`è½¬ä¹‰
		// æ”¯æŒunicode
		let dollarSign = "\u{24}"

		// Characters
		for character in "Dog!ğŸ¶" {
				print(character)
		}
		let catCharacters: [Character] = ["C", "a", "t", "!", "ğŸ±"]

		// `#` æ‰©å±•å­—ç¬¦ä¸²åˆ†éš”ç¬¦
		let str1 = #"Line 1\nLine 2"#
		ç›¸å½“äº
		let str2 = "Line 1\\nLine 2"

		let str3 = ###"Line1\###nLine2"###
		ç›¸å½“äº
		let str4 = "Line1\nLine2"

		// String Interpolation
		let multiplier = 3
		let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)"

### Unicode

		let greeting = "Guten Tag!"
		greeting[greeting.startIndex]
		// G
		greeting[greeting.index(before: greeting.endIndex)]
		// !
		greeting[greeting.index(after: greeting.startIndex)]
		// u
		let index = greeting.index(greeting.startIndex, offsetBy: 7)
		greeting[index]
		// a

		var welcome = "hello"
		welcome.insert("!", at: welcome.endIndex)
		welcome.insert(contentsOf: " there", at: welcome.index(before: welcome.endIndex))

		welcome.remove(at: welcome.index(before: welcome.endIndex))
		let range = welcome.index(welcome.endIndex, offsetBy: -6)..<welcome.endIndex
			welcome.removeSubrange(range)

		// substrings
		let greeting = "Hello, world!"
		let index = greeting.firstIndex(of: ",") ?? greeting.endIndex
		let beginning = greeting[..<index]

		let newString = String(beginning)
		hasPrefix(_:)
		hasSuffix(_:)

		// å­—ç¬¦ä¸²çš„ Unicode è¡¨ç¤º
		A collection of UTF-8 code units (accessed with the stringâ€™s utf8 property)
		A collection of UTF-16 code units (accessed with the stringâ€™s utf16 property)
		A collection of 21-bit Unicode scalar values, equivalent to the stringâ€™s UTF-32 encoding form (accessed with the stringâ€™s unicodeScalars property)

### é›†åˆ

		// åˆ›å»ºç©ºæ•°ç»„æˆ–è€…å­—å…¸
		let emptyArray: [String] = []
		let emptyDictionary: [String: Float] = [:]

		// Array
		var arr : [Int] = [] // å¯å˜çš„
		let arr : [Int] = [] // ä¸å¯å˜çš„

		var threeDoubles = Array(repeating: 0.0, count: 3)
		var anotherThreeDoubles = Array(repeating: 2.5, count: 3)
		var sixDoubles = threeDoubles + anotherThreeDoubles
		var shoppingList: [String] = ["Eggs", "Milk"]
		print("The shopping list contains \(shoppingList.count) items.")
		if shoppingList.isEmpty {
				print("The shopping list is empty.")
		} else {
				print("The shopping list isn't empty.")
		}

		shoppingList.append("Flour")
		shoppingList += ["Baking Powder"]
		shoppingList[4...6] = ["Bananas", "Apples"]
		shoppingList.insert("Maple Syrup", at: 0)
		let apples = shoppingList.removeLast()
		for item in shoppingList {
				print(item)
		}

		for (index, value) in shoppingList.enumerated() {
				print("Item \(index + 1): \(value)")
		}

		// Set
		var letters = Set<Character>()
		letters.insert("a")
		var favoriteGenres: Set<String> = ["Rock", "Classical", "Hip hop"]
		if let removedGenre = favoriteGenres.remove("Rock") {
				print("\(removedGenre)? I'm over it.")
		} else {
				print("I never much cared for that.")
		}

		a.intersecion(b) // äº¤é›†
		a.symmetricDifference(b) // éäº¤é›†
		a.union(b) // å¹¶é›†
		a.subtracting(b) // a - b

		Use the intersection(_:) method to create a new set with only the values common to both sets.
		Use the symmetricDifference(_:) method to create a new set with values in either set, but not both.
		Use the union(_:) method to create a new set with all of the values in both sets.
		Use the subtracting(_:) method to create a new set with values not in the specified set.

		Use the â€œis equalâ€ operator (==) to determine whether two sets contain all of the same values.
		Use the isSubset(of:) method to determine whether all of the values of a set are contained in the specified set.
		Use the isSuperset(of:) method to determine whether a set contains all of the values in a specified set.
		Use the isStrictSubset(of:) or isStrictSuperset(of:) methods to determine whether a set is a subset or superset, but not equal to, a specified set.
		Use the isDisjoint(with:) method to determine whether two sets have no values in common.

		// Dictionaries
		var namesOfIntegers: [Int: String] = [:]
		var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]
		airports["LHR"] = "London"
		if let oldValue = airports.updateValue("Dublin Airport", forKey: "DUB") {
				print("The old value for DUB was \(oldValue).")
		}
		if let removedValue = airports.removeValue(forKey: "DUB") {
				print("The removed airport's name is \(removedValue).")
		} else {
				print("The airports dictionary doesn't contain a value for DUB.")
		}

		// Iterating Over a dictionary
		for (airportCode, airportName) in airports {
				print("\(airportCode): \(airportName)")
		}
		for airportCode in airports.keys {
				print("Airport code: \(airportCode)")
		}
		for airportName in airports.values {
				print("Airport name: \(airportName)")
		}
		let airportCodes = [String](airports.keys)
		let airportNames = [String](airports.values)
	
### æµç¨‹æ§åˆ¶

		// æ¡ä»¶æˆ–è€…å¾ªç¯ä¸­çš„æ‹¬å·æ˜¯å¯é€‰çš„
		if a == b {}

		// if è¯­å¥æ¡ä»¶å¿…é¡»æ˜¯Booleanè¡¨è¾¾å¼, ä¸ä¼šéšå¼è½¬æ¢æ•°å€¼
		if (1) {} //æ˜¯é”™è¯¯çš„

		// if + let è¯­å¥å¯ä»¥å¤„ç†å¯èƒ½ä¸ºnilçš„å€¼
		var optionalName: String? = "John Appleseed"
		var greeting = "Hello!"
		if let name = optionalName {
				greeting = "Hello, \(name)"
		}

		// ä½¿ç”¨`??`ä¹Ÿå¯ä»¥å¤„ç†å¯é€‰å€¼
		let nickname: String? = nil
		let fullName: String = "John Appleseed"
		let informalGreeting = "Hi \(nickname ?? fullName)"

		// swift æ”¯æŒä»»ä½•ç±»å‹å’Œä»»ä½•æ¯”è¾ƒ, swiftä¸æ˜¯è´¯é€šçš„
		let vegetable = "red pepper"
		switch vegetable {
		case "celery":
				print("Add some raisins and make ants on a log.")
		case "cucumber", "watercress":
				print("That would make a good tea sandwich.")
		case let x where x.hasSuffix("pepper"):
				print("Is it a spicy \(x)?")
		default:
				print("Everything tastes good in soup.")
		}
		// ä½¿ç”¨åŒºé—´
		let approximateCount = 62
		let countedThings = "moons orbiting Saturn"
		let naturalCount: String
		switch approximateCount {
		case 0:
				naturalCount = "no"
		case 1..<5:
				naturalCount = "a few"
		case 5..<12:
				naturalCount = "several"
		case 12..<100:
				naturalCount = "dozens of"
		case 100..<1000:
				naturalCount = "hundreds of"
		default:
				naturalCount = "many"
		}
		// ä½¿ç”¨tuples
		let somePoint = (1, 1)
		switch somePoint {
		case (0, 0):
				print("\(somePoint) is at the origin")
		case (_, 0):
				print("\(somePoint) is on the x-axis")
		case (0, _):
				print("\(somePoint) is on the y-axis")
		case (-2...2, -2...2):
				print("\(somePoint) is inside the box")
		default:
				print("\(somePoint) is outside of the box")
		}
		// å€¼ç»‘å®š
		let anotherPoint = (2, 0)
		switch anotherPoint {
		case (let x, 0):
				print("on the x-axis with an x value of \(x)")
		case (0, let y):
				print("on the y-axis with a y value of \(y)")
		case let (x, y):
				print("somewhere else at (\(x), \(y))")
		}
		// where
		let yetAnotherPoint = (1, -1)
		switch yetAnotherPoint {
		case let (x, y) where x == y:
				print("(\(x), \(y)) is on the line x == y")
		case let (x, y) where x == -y:
				print("(\(x), \(y)) is on the line x == -y")
		case let (x, y):
				print("(\(x), \(y)) is just some arbitrary point")
		}
		// å¤åˆæ¡ˆä¾‹
		let someCharacter: Character = "e"
		switch someCharacter {
		case "a", "e", "i", "o", "u":
				print("\(someCharacter) is a vowel")
		case "b", "c", "d", "f", "g", "h", "j", "k", "l", "m",
				 "n", "p", "q", "r", "s", "t", "v", "w", "x", "y", "z":
				print("\(someCharacter) is a consonant")
		default:
				print("\(someCharacter) isn't a vowel or a consonant")
		}

		// ä½¿ç”¨`for - in`è¿­ä»£åºåˆ—, array/dictionary
		let interestingNumbers = [
    "Prime": [2, 3, 5, 7, 11, 13],
    "Fibonacci": [1, 1, 2, 3, 5, 8],
    "Square": [1, 4, 9, 16, 25],
		]
		var largest = 0
		for (_, numbers) in interestingNumbers {
				for number in numbers {
						if number > largest {
								largest = number
						}
				}
		}

		// ä½¿ç”¨`while`æˆ–è€…`repeat while`æ¥é‡å¤ä¸€æ®µä»£ç , ç›´åˆ°æ¡ä»¶åˆ°è¾¾
		var n = 2
		while n < 100 {
				n *= 2
		}

		var m = 2
		repeat {
				m *= 2
		} while m < 100

		// å¯ä»¥ä½¿ç”¨range
		var total = 0
		for i in 0..<4 {
				total += i
		}

		// tuple å…ƒç»„
		let a : (min: Int, max: Int, sum: Int) = (1, 2, 3)

		// æµç¨‹è·³è½¬
		continue
		break
		fallthrough
		return
		throw

		// æ ‡è®°è¯­å¥  Labeled statements
		label name: while condition {
				statements
		}
		break <label name>

		// æå‰é€€å‡º
		guard let name = person["name"] else {
        return
    }

		// æ£€æŸ¥APIç‰ˆæœ¬
		if #available(iOS 10, macOS 10.12, *) {
				// Use iOS 10 APIs on iOS, and use macOS 10.12 APIs on macOS
		} else {
				// Fall back to earlier iOS and macOS APIs
		}

		if #available(platform name version, ..., *) {
				statements to execute if the APIs are available
		} else {
				fallback statements to execute if the APIs are unavailable
		}

### å‡½æ•°å’Œé—­åŒ…(Closures) 

		// `func`å®šä¹‰å‡½æ•°, `->` æŒ‡å®šè¿”å›ç±»å‹
		func greet(person: String, day: String) -> String {
				return "Hello \(person), today is \(day)."
		}
		greet(person: "Bob", day: "Tuesday")

		// é€šå¸¸ä½¿ç”¨å‚æ•°åç§°æ¥ä¼ é€’å‚æ•°, å¯ä»¥ä½¿ç”¨`_`æŒ‡å®šå‚æ•°å¯ä»¥ä¸ä½¿ç”¨å‚æ•°åç§°
		func greet(_ person: String, on day: String) -> String {
			return "Hello \(person), today is \(day)."
		}
		greet("John", on: "Wednesday")

		// è¿”å›å€¼å¯ä»¥æ˜¯å…ƒç»„
		func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
				var min = scores[0]
				var max = scores[0]
				var sum = 0

				for score in scores {
						if score > max {
								max = score
						} else if score < min {
								min = score
						}
						sum += score
				}

				return (min, max, sum)
		}

		// Functions With an Implicit return
		func greeting(for person: String) -> String {
				"Hello, " + person + "!"
		}

		// Function Argument Labels and Parameter Names
		func someFunction(argumentLabel parameterName: Int) {
				// In the function body, parameterName refers to the argument value
				// for that parameter.
		}

		// Omitting Argument Labels
		func someFunction(_ firstParameterName: Int, secondParameterName: Int) {
				// In the function body, firstParameterName and secondParameterName
				// refer to the argument values for the first and second parameters.
		}

		// Default Parameter Values
		func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) {
				// If you omit the second argument when calling this function, then
				// the value of parameterWithDefault is 12 inside the function body.
		}

		// Variadic Parameters
		func arithmeticMean(_ numbers: Double...) -> Double {
				var total: Double = 0
				for number in numbers {
						total += number
				}
				return total / Double(numbers.count)
		}

		// In-Out Parameters, é»˜è®¤å‚æ•°æ˜¯å¸¸é‡, å¦‚æœéœ€è¦æ”¹å˜å‚æ•°çš„å€¼, ä½¿ç”¨`inout` å…³é”®å­—
		func swapTwoInts(_ a: inout Int, _ b: inout Int) {
				let temporaryA = a
				a = b
				b = temporaryA
		}

		// å‡½æ•°ç±»å‹
		var mathFunction: (Int, Int) -> Int = addTwoInts

		// é—­åŒ…: å‡½æ•°å¯ä»¥åµŒå¥—, å†…éƒ¨å‡½æ•°å¯ä»¥è®¿é—®å¤–éƒ¨å‡½æ•°çš„å˜é‡; å‡½æ•°æ˜¯ä¸€çº§å¯¹è±¡, å‡½æ•°å¯ä»¥è¿”å›å¦ä¸€ä¸ªå‡½æ•°
		func returnFifteen() -> ((Int) -> Int) {
				var y = 10
				func add(num: Int) -> Int {
						num += 5
						return num;
				}
				y = add(y)
				return add
		}

		// ä¸€ä¸ªå‡½æ•°å¯ä»¥åšä¸ºå¦ä¸€ä¸ªå‡½æ•°çš„å‚æ•°
		func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
				for item in list {
						if condition(item) {
								return true
						}
				}
				return false
		}
		func lessThanTen(number: Int) -> Bool {
				return number < 10
		}
		var numbers = [20, 19, 7, 12]
		hasAnyMatches(list: numbers, condition: lessThanTen)

		// åˆ›å»ºåŒ¿åé—­åŒ…`({})`
		{ (parameters) -> return type in
				statements
		}
		numbers.map({ (number: Int) -> Int in
				let result = 3 * number
				return result
		})

		// å½“é—­åŒ…å‚æ•°ç±»å‹å·²çŸ¥, è¿”å›ç±»å‹å·²çŸ¥, é‚£ä¹ˆå¯ä»¥å¿½ç•¥å‚æ•°å’Œè¿”å›ç±»å‹
		let mappedNumbers = numbers.map({ number in 3 * number })
		print(mappedNumbers)

		// å½“é—­åŒ…å¾ˆç®€çŸ­, é‚£ä¹ˆå¯ä»¥ç”¨ä¸‹æ ‡è®¿é—®å‚æ•°, å¦‚æœé—­åŒ…æ˜¯å”¯ä¸€å‚æ•°, é‚£ä¹ˆ`()`å¯ä»¥å¿½ç•¥
		let sortedNumbers = numbers.sorted { $0 > $1 }
		print(sortedNumbers)

		// Operator Methods
		reversedNames = names.sorted(by: >)

		// @noescape @escaping @autoclosure
		@noescape å·²å¼ƒç”¨, é»˜è®¤. åªåœ¨å‡½æ•°å†…ä½¿ç”¨, å‡½æ•°ç»“æŸå, é—­åŒ…ç”Ÿå‘½å‘¨æœŸç»“æŸ
		@escaping å¯ä»¥åœ¨å‡½æ•°ç”Ÿå‘½å‘¨æœŸå¤–ä½¿ç”¨, é—­åŒ…ä¸€èˆ¬åœ¨å‡½æ•°ç»“æŸåè°ƒç”¨
		@autoclosure é»˜è®¤@escaping, ä¸æ¥æ”¶å‚æ•°, è‡ªåŠ¨å°†è¡¨è¾¾å¼è½¬æ¢æˆé—­åŒ…

		// å½“å¯¹è±¡ä¸ºå¸¸é‡(let)æ—¶, ä¸èƒ½è°ƒç”¨mutating æ–¹æ³•, å› ä¸ºä»–ä¸å¯å˜
		// Assigning to self Within a Mutating Method
		struct Point {
				var x = 0.0, y = 0.0
				mutating func moveBy(x deltaX: Double, y deltaY: Double) {
						self = Point(x: x + deltaX, y: y + deltaY)
				}
		}

		// `class` ä¿®æ”¹å¯¹è±¡æ–¹æ³•, å¯ä»¥æˆä¸ºç±»å‹æ–¹æ³•, ç±»å‹æ–¹æ³•é‡Œçš„selfæŒ‡å‘ç±»å‹æœ¬èº«
		class SomeClass {
				class func someTypeMethod() {
						// type method implementation goes here
				}
		}
		SomeClass.someTypeMethod()

### å¯¹è±¡å’Œç±»

æ ¹ç±»
* Any can represent an instance of any type at all, including function types.
* AnyObject can represent an instance of any class type.
* `weak` å¼±å¼•ç”¨; `Unowned` æ— ä¸»å¼•ç”¨

> æ”¯æŒåµŒå¥—ç±»å‹

		// ä½¿ç”¨`class`åˆ›å»ºç±», å£°æ˜å±æ€§å’Œæ–¹æ³•è·Ÿå˜é‡å’Œå‡½æ•°ä¸€æ ·.
		class Shape {
				var numberOfSides = 0
				func simpleDescription() -> String {
						return "A shape with \(numberOfSides) sides."
				}
		}

		// åˆ›å»ºå¯¹è±¡, è®¿é—®å±æ€§å’Œæ–¹æ³•
		var shape = Shape()
		shape.numberOfSides = 7
		var shapeDescription = shape.simpleDescription()

		// `init` æ–¹æ³•ä¸ºæ„é€ æ–¹æ³•, `self`ä»£è¡¨å½“å‰å¯¹è±¡
		// `deinit` é‡Šæ”¾å¯¹è±¡
		// `:` æŒ‡å®šè¶…ç±»(ä¸æ”¯æŒå¤šé‡ç»§æ‰¿), `super`å¼•ç”¨è¶…ç±», `override`é‡å†™è¶…ç±»æ–¹æ³•
		class Square: NamedShape {
				var sideLength: Double

				init(sideLength: Double, name: String) {
						self.sideLength = sideLength
						super.init(name: name)
						numberOfSides = 4
				}

				func area() -> Double {
						return sideLength * sideLength
				}

				override func simpleDescription() -> String {
						return "A square with sides of length \(sideLength)."
				}
		}

		// override å¯ä»¥é‡å†™æ–¹æ³•å’Œå±æ€§, ä½¿ç”¨`final` é˜²æ­¢é‡å†™

		// å±æ€§`lazy`, å½“ç¬¬ä¸€æ¬¡è®¿é—®æ—¶åˆå§‹åŒ–, æ”¯æŒå…¨å±€å¸¸é‡å’Œå˜é‡
		// åªæœ‰getteræ–¹æ³•, æ²¡æœ‰setterå°±æ˜¯åªè¯»å±æ€§

		// `propertyWrapper`, å±æ€§getter, setteråŒ…è£…å™¨
		@propertyWrapper
		struct TwelveOrLess {
				private var number = 0
				var wrappedValue: Int {
						get { return number }
						set { number = min(newValue, 12) }
				}
		}

		struct SmallRectangle {
				@TwelveOrLess var height: Int
				@TwelveOrLess var width: Int
		}

		// `projectedValue` æ˜ å°„å€¼, åœ¨å±æ€§å‰åŠ ä¸Š`$`å¼•ç”¨æ˜ å°„å€¼
		@propertyWrapper
		struct SmallNumber {
				private var number: Int
				private(set) var projectedValue: Bool

				var wrappedValue: Int {
						get { return number }
						set {
								if newValue > 12 {
										number = 12
										projectedValue = true
								} else {
										number = newValue
										projectedValue = false
								}
						}
				}

				init() {
						self.number = 0
						self.projectedValue = false
				}
		}

		struct SomeStructure {
				@SmallNumber var someNumber: Int
		}

		var someStructure = SomeStructure()

		someStructure.someNumber = 4
		print(someStructure.$someNumber)

		// å±æ€§å¯ä»¥æœ‰`getter`å’Œ`setter`æ–¹æ³•, `newValue` å½“setterè¢«è°ƒç”¨æ—¶, ä¼ è¿›æ¥çš„å€¼éšå¼åç§°
		class EquilateralTriangle: NamedShape {
				var sideLength: Double = 0.0

				init(sideLength: Double, name: String) {
						self.sideLength = sideLength
						super.init(name: name)
						numberOfSides = 3
				}

				var perimeter: Double {
						get {
								return 3.0 * sideLength
						}
						set {
								sideLength = newValue / 3.0
						}
				}

				override func simpleDescription() -> String {
						return "An equilateral triangle with sides of length \(sideLength)."
				}
		}

		// å±æ€§å¯ä»¥æœ‰`willSet`å’Œ`didSet`, å½“å€¼è®¾ç½®å‰å’Œè®¾ç½®åè°ƒç”¨
		var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }

		// ä¸å¯¹è±¡æ˜¯å¯é€‰ç±»å‹æ—¶, å¯ä»¥ä½¿ç”¨`?`è°ƒç”¨
		// Optional Chaining
		let optionalSquare: Square? = Square(sideLength: 2.5, name: "optional square")
		let sideLength = optionalSquare?.sideLength

		// `static` ä¿®æ”¹å±æ€§ä¸ºç±»å‹å±æ€§, é»˜è®¤lazy, åªæœ‰åˆå§‹åŒ–ä¸€æ¬¡, å¿…é¡»è¢«åˆå§‹åŒ–

		// convenience init æ˜¯designed initæ‰©å±•, å¿…é¡»è°ƒç”¨designed init

		// `is` å’Œ `as` æ¥åˆ¤æ–­å’Œå¼ºè½¬ç±»å‹ as? å¯é€‰é¡¹; as! å¼ºåˆ¶

### æƒä¸¾å’Œç»“æ„

		// `enum`åˆ›å»ºæƒä¸¾, æƒä¸¾å¯ä»¥æœ‰è‡ªå·±çš„æ–¹æ³•, é»˜è®¤æƒä¸¾ä¸‹æ ‡`rawValue`ä»0å¼€å§‹
		// rawValue è¿˜å¯ä»¥ä½¿ç”¨å­—ç¬¦ä¸²å’Œæµ®ç‚¹å€¼ç±»å‹
		enum Rank: Int {
				case ace = 1
				case two, three, four, five, six, seven, eight, nine, ten
				case jack, queen, king

				func simpleDescription() -> String {
						switch self {
						case .ace:
								return "ace"
						case .jack:
								return "jack"
						case .queen:
								return "queen"
						case .king:
								return "king"
						default:
								return String(self.rawValue)
						}
				}
		}
		let ace = Rank.ace
		let aceRawValue = ace.rawValue

		// éå†æƒä¸¾
		for beverage in Beverage.allCases {
				print(beverage)
		}

		// `init?(rawValue:)` ä½¿ç”¨åŸå§‹å€¼åŒ¹é…æƒä¸¾å€¼, ä¸åŒ¹é…è¿”å›nil
		if let convertedRank = Rank(rawValue: 3) {
				let threeDescription = convertedRank.simpleDescription()
		}

		// åªæœ‰ä¸€ä¸ªrawValueå€¼, å€¼å’Œæ¡ˆä¾‹å…³è”, å€¼æ˜¯åˆ›å»ºæƒä¸¾å€¼æ—¶ä¼ å…¥
		enum ServerResponse {
				case result(String, String)
				case failure(String)
		}

		let success = ServerResponse.result("6:00 am", "8:09 pm")
		let failure = ServerResponse.failure("Out of cheese.")

		switch success {
		case let .result(sunrise, sunset):
				print("Sunrise is at \(sunrise) and sunset is at \(sunset).")
		case let .failure(message):
				print("Failure...  \(message)")
		}

		// Recursive Enumerations, `indirect` å¯ä»¥å¼•ç”¨è‡ªå·±
		enum ArithmeticExpression {
				case number(Int)
				indirect case addition(ArithmeticExpression, ArithmeticExpression)
				indirect case multiplication(ArithmeticExpression, ArithmeticExpression)
		}

		indirect enum ArithmeticExpression {
				case number(Int)
				case addition(ArithmeticExpression, ArithmeticExpression)
				case multiplication(ArithmeticExpression, ArithmeticExpression)
		}

		func evaluate(_ expression: ArithmeticExpression) -> Int {
				switch expression {
				case let .number(value):
						return value
				case let .addition(left, right):
						return evaluate(left) + evaluate(right)
				case let .multiplication(left, right):
						return evaluate(left) * evaluate(right)
				}
		}

		// `struct`åˆ›å»ºç»“æ„, ç»“æ„ä¹Ÿå¯ä»¥æœ‰å±æ€§å’Œæ–¹æ³•, å’Œç±»åŒºåˆ«æ˜¯copiedä¼ é€’, ç±»æ˜¯å¼•ç”¨ä¼ é€’
		struct Card {
				var rank: Rank
				var suit: Suit
				func simpleDescription() -> String {
						return "The \(rank.simpleDescription()) of \(suit.simpleDescription())"
				}
		}
		let threeOfSpades = Card(rank: .three, suit: .spades)
		let threeOfSpadesDescription = threeOfSpades.simpleDescription()

		// Structures and Enumerations Are Value Types
		let hd = Resolution(width: 1920, height: 1080)
		var cinema = hd
		cinema.width = 2048
		cinema !== hd

		// Identity Operators
		Identical to (===)
		Not identical to (!==)

		// Access Control
* public - Open access and public access enable entities to be used within any source file from their defining module, and also in a source file from another module that imports the defining module. You typically use open or public access when specifying the public interface to a framework. The difference between open and public access is described below.
* internal(é»˜è®¤) - Internal access enables entities to be used within any source file from their defining module, but not in any source file outside of that module. You typically use internal access when defining an appâ€™s or a frameworkâ€™s internal structure.
* fileprivate - File-private access restricts the use of an entity to its own defining source file. Use file-private access to hide the implementation details of a specific piece of functionality when those details are used within an entire file.
* private - Private access restricts the use of an entity to the enclosing declaration, and to extensions of that declaration that are in the same file. Use private access to hide the implementation details of a specific piece of functionality when those details are used only within a single declaration.
	

### Subscripts
		// `subscript`, æ”¯æŒä»»æ„æ•°é‡å…¥å‚, æ”¯æŒç±»å‹æ–¹æ³•
		struct TimesTable {
				let multiplier: Int
				subscript(index: Int) -> Int {
						return multiplier * index
				}
		}



### Protocols and Extensions

		// `protocol` å®šä¹‰ä¸€ä¸ªåè®®
		protocol ExampleProtocol {
				var simpleDescription: String { get }
				mutating func adjust()
		}

		// ç±», æƒä¸¾, ç»“æ„éƒ½å¯ä»¥å®ç°åè®®. 
		// ç»“æ„å®ç°åè®®æ–¹æ³•, éœ€è¦`mutating`ä¿®é¥°, è¡¨ç¤ºæ˜¯å¯ä¿®æ”¹çš„; ç±»ä¸ç”¨, å› ä¸ºç±»çš„æ–¹æ³•
		// éƒ½æ˜¯å¯ä»¥ä¿®æ”¹çš„
		class SimpleClass: ExampleProtocol {
				var simpleDescription: String = "A very simple class."
				var anotherProperty: Int = 69105
				func adjust() {
						simpleDescription += "  Now 100% adjusted."
				}
		}
		var a = SimpleClass()
		a.adjust()
		let aDescription = a.simpleDescription

		struct SimpleStructure: ExampleProtocol {
				var simpleDescription: String = "A simple structure"
				mutating func adjust() {
						simpleDescription += " (adjusted)"
				}
		}
		var b = SimpleStructure()
		b.adjust()
		let bDescription = b.simpleDescription

		// `extension` æ‰©å±•å·²å­˜åœ¨çš„ç±»å‹, ç‰¹åˆ«ç”¨äºåœ¨ç±»å‹ä¸Šæ‰©å±•ä¸€è‡´çš„åè®®
		extension Int: ExampleProtocol {
				var simpleDescription: String {
						return "The number \(self)"
				}
				mutating func adjust() {
						self += 42
				}
		}

		// Extension Syntax
		extension SomeType {
				// new functionality to add to SomeType goes here
		}
		// Computed Properties
		extension Double {
				var km: Double { return self * 1_000.0 }
				var m: Double { return self }
				var cm: Double { return self / 100.0 }
				var mm: Double { return self / 1_000.0 }
				var ft: Double { return self / 3.28084 }
		}
		// Extension Initializers
		extension Rect {
				init(center: Point, size: Size) {
						let originX = center.x - (size.width / 2)
						let originY = center.y - (size.height / 2)
						self.init(origin: Point(x: originX, y: originY), size: size)
				}
		}
		// Extension Methods
		extension Int {
				func repetitions(task: () -> Void) {
						for _ in 0..<self {
								task()
						}
				}
		}
		// Extension Subscripts
		extension Int {
				subscript(digitIndex: Int) -> Int {
						var decimalBase = 1
						for _ in 0..<digitIndex {
								decimalBase *= 10
						}
						return (self / decimalBase) % 10
				}
		}
		// Nested Types
		extension Int {
				enum Kind {
						case negative, zero, positive
				}
				var kind: Kind {
						switch self {
						case 0:
								return .zero
						case let x where x > 0:
								return .positive
						default:
								return .negative
						}
				}
		}

		// åè®®å¯ä»¥ä½œä¸ºç±»å‹, å½“åè®®ä½œä¸ºç±»å‹æ—¶, å…¶ä»–æ–¹æ³•éšè—ä¸å¯ç”¨
		// Protocol Syntax
		protocol SomeProtocol {
				// protocol definition goes here
		}
		// Property Requirements; gettable settable
		protocol SomeProtocol {
				var mustBeSettable: Int { get set }
				var doesNotNeedToBeSettable: Int { get }
		}
		// Method Requirements
		protocol RandomNumberGenerator {
				func random() -> Double
		}
		// Mutating Method Requirements, å…è®¸è¯¥æ–¹æ³•ä¿®æ”¹å±æ€§å’Œå¯¹è±¡
		protocol Togglable {
				mutating func toggle()
		}
		enum OnOffSwitch: Togglable {
				case off, on
				mutating func toggle() {
						switch self {
						case .off:
								self = .on
						case .on:
								self = .off
						}
				}
		}
		// Initializer Requirements
		protocol SomeProtocol {
				init(someParameter: Int)
		}
		class SomeClass: SomeProtocol {
				required init(someParameter: Int) {
						// initializer implementation goes here
				}
		}



### å¼‚å¸¸å¤„ç†

		// `Error` è¡¨ç¤ºé”™è¯¯
		enum PrinterError: Error {
				case outOfPaper
				case noToner
				case onFire
		}

		func canThrowAnError() throws {
				// this function may or may not throw an error
		}

		do {
				try canThrowAnError()
				// no error was thrown
		} catch {
				// an error was thrown
		}

		// `throw` æŠ›å‡ºé”™è¯¯
		func send(job: Int, toPrinter printerName: String) throws -> String {
				if printerName == "Never Has Toner" {
						throw PrinterError.noToner
				}
				return "Job sent"
		}

		// `do - catch`å¤„ç†é”™è¯¯
		do {
				let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
				print(printerResponse)
		} catch PrinterError.onFire {
				print("I'll just put this over here, with the rest of the fire.")
		} catch let printerError as PrinterError {
				print("Printer error: \(printerError).")
		} catch {
				print(error)
		}

		// `try?` å¤„ç†é”™è¯¯, å¯ä»¥æŠŠè¿”å›è½¬æ¢æˆå¯é€‰å€¼, å¦‚æœæœ‰å¼‚å¸¸å°±è¿”å›nil
		let printerSuccess = try? send(job: 1884, toPrinter: "Mergenthaler")

		// try é…åˆdo-catch, èµ·åˆ°ä¼ æ’­å¼‚å¸¸çš„ä½œç”¨, try! å¼ºåˆ¶è§£åŒ…

		// `defer` ä¼šåœ¨returnå‰æ‰§è¡Œ, æŠ›å‡ºå¼‚å¸¸ä¹Ÿä¼šæ‰§è¡Œ, å¯ä»¥åœ¨è®¾ç½®æ—è¾¹ç¼–å†™`defer`æ¸…ç†ä»£ç 
		func fridgeContains(_ food: String) -> Bool {
				fridgeIsOpen = true
				defer {
						fridgeIsOpen = false
				}

				let result = fridgeContent.contains(food)
				return result
		}

		// æ‰“å°é”™è¯¯ä¿¡æ¯å¹¶åœæ­¢
		fatalError(_:file:line:)

### æ³›å‹(Generice)

		// `<Item>` åˆ›å»ºä¸€ä¸ªæ³›å‹
		func makeArray<Item>(repeating item: Item, numberOfTimes: Int) -> [Item] {
				var result: [Item] = []
				for _ in 0..<numberOfTimes {
						result.append(item)
				}
				return result
		}
		makeArray(repeating: "knock", numberOfTimes: 4)

		// å‡½æ•°, æ–¹æ³•, ç±», æƒä¸¾, ç»“æ„å¯ä»¥ä½¿ç”¨æ³›å‹
		enum OptionalValue<Wrapped> {
				case none
				case some(Wrapped)
		}
		var possibleInteger: OptionalValue<Int> = .none
		possibleInteger = .some(100)

		// `where` å‡½æ•°å’Œæ–¹æ³•bodyå‰, æŒ‡å®šä¸€åˆ—è¡¨éœ€æ±‚
		func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
				where T.Element: Equatable, T.Element == U.Element
		{
				for lhsItem in lhs {
						for rhsItem in rhs {
								if lhsItem == rhsItem {
										return true
								}
						}
				}
				return false
		}
		anyCommonElements([1, 2, 3], [3])

		// Opaque Types `some`

### Concurrency

		// `async` è¡¨æ˜ä¸€ä¸ªå‡½æ•°æˆ–æ–¹æ³•æ˜¯å¼‚æ­¥çš„, å†™åœ¨`throws` æˆ–è€…`->` ä¹‹å‰
		func listPhotos(inGallery name: String) async throws -> [String] {
				let result = // ... some asynchronous networking code ...
				return result
		}

		// `await` è®¾ç½®æŒ‚è½½ç‚¹, å½“å¼‚æ­¥æ–¹æ³•è¿”å›æˆ–æŠ›å‡ºå¼‚å¸¸æ—¶, ç»§ç»­æ‰§è¡Œä¸‹ä¸€æ­¥

è¿™äº›åœ°æ–¹å¯ä»¥è°ƒç”¨å¼‚æ­¥æ–¹æ³•:
* Code in the body of an asynchronous function, method, or property.
* Code in the static main() method of a structure, class, or enumeration thatâ€™s marked with @main.
* Code in an unstructured child task, as shown in Unstructured Concurrency below.

		// downloadPhotoæ˜¯å¼‚æ­¥çš„, ä½†æ˜¯éœ€è¦ä¸€æ¡æ¡çš„æ‰§è¡Œ
		let firstPhoto = await downloadPhoto(named: photoNames[0])
		let secondPhoto = await downloadPhoto(named: photoNames[1])
		let thirdPhoto = await downloadPhoto(named: photoNames[2])

		let photos = [firstPhoto, secondPhoto, thirdPhoto]
		show(photos)

		// for-await-in å¯ä»¥ç­‰å¾…ä¸‹ä¸€ä¸ªå¯ä»¥é¡¹
		for try await line in photos {
				print(line)
		}

		// Parallel, å¹¶è¡Œæ‰§è¡Œå¼‚æ­¥æ–¹æ³•
		async let firstPhoto = downloadPhoto(named: photoNames[0])
		async let secondPhoto = downloadPhoto(named: photoNames[1])
		async let thirdPhoto = downloadPhoto(named: photoNames[2])

		let photos = await [firstPhoto, secondPhoto, thirdPhoto]
		show(photos)

#### Tasks and Task Groups

> structured concurrency
> Taskæ˜¯å¼‚æ­¥è¿è¡Œçš„å·¥ä½œå•å…ƒ, æ‰€æœ‰å¼‚æ­¥ä»£ç éƒ½ä½œä¸ºTaskçš„ä¸€éƒ¨åˆ†è¿è¡Œ. async-let ä¼šåˆ›å»ºä¸€ä¸ªå­ä»»åŠ¡è¿è¡Œ.
> Task Groupæ˜¯ç®¡ç†Taskçš„, æ·»åŠ åˆ é™¤, è®¾ç½®æ•°é‡ç­‰
> ä»»åŠ¡æŒ‰å±‚æ¬¡ç»“æ„æ’åˆ—, åœ¨åŒä¸€ä»»åŠ¡ç»„ä¸­æ‰€æœ‰ä»»åŠ¡éƒ½æœ‰åŒä¸€ä¸ªçˆ¶ä»»åŠ¡, ä»»åŠ¡éƒ½å¯ä»¥æœ‰è‡ªå·±çš„å­ä»»åŠ¡.


		await withTaskGroup(of: Data.self) { taskGroup in
				let photoNames = await listPhotos(inGallery: "Summer Vacation")
				for name in photoNames {
						taskGroup.addTask { await downloadPhoto(named: name) }
				}
		}

> ä½¿ç”¨`withTaskGroup`åˆ›å»ºä»»åŠ¡ç»„, ä½¿ç”¨`addTask`æ·»åŠ ä»»åŠ¡

> Unstructured concurrency
> Task.init(priority:operation:)
> Task.detached(priority:operation:)

ä»»åŠ¡å–æ¶ˆ:
* Throwing an error like CancellationError
* Returning nil or an empty collection
* Returning the partially completed work

Task.checkCancellation() å½“ä»»åŠ¡å·²å–æ¶ˆä¼šæŠ›CancellationErrorå¼‚å¸¸
Task.isCancelled æ£€æŸ¥æ˜¯å¦å·²ç»å–æ¶ˆ
Task.cancel() æ‰‹åŠ¨å–æ¶ˆ

> `Actor` è·Ÿç±»ä¸€æ ·æ˜¯å¼•ç”¨ç±»å‹, ä¸ç±»çš„åŒºåˆ«æ˜¯, ä¸€æ¬¡åªå‡†ä¸€ä¸ªä»»åŠ¡è®¿é—®ä»–çš„çŠ¶æ€

### é«˜çº§æ“ä½œ

#### Bitwise Operators
	
	// é
	let initialBits: UInt8 = 0b00001111
	let invertedBits = ~initialBits  // equals 11110000
	// ä¸
	let firstSixBits: UInt8 = 0b11111100
	let lastSixBits: UInt8  = 0b00111111
	let middleFourBits = firstSixBits & lastSixBits  // equals 00111100
	// æˆ–
	let someBits: UInt8 = 0b10110010
	let moreBits: UInt8 = 0b01011110
	let combinedbits = someBits | moreBits  // equals 11111110
	// å¼‚æˆ–
	let firstBits: UInt8 = 0b00010100
	let otherBits: UInt8 = 0b00000101
	let outputBits = firstBits ^ otherBits  // equals 00010001
	// å·¦ç§» å³ç§»
	let shiftBits: UInt8 = 4   // 00000100 in binary
	shiftBits << 1             // 00001000
	shiftBits << 2             // 00010000
	shiftBits << 5             // 10000000
	shiftBits << 6             // 00000000
	shiftBits >> 2             // 00000001

#### Overflow Operators

	var potentialOverflow = Int16.max
	potentialOverflow += 1 // this causes an Error

Overflow addition (&+)
Overflow subtraction (&-)
Overflow multiplication (&*)

	var unsignedOverflow = UInt8.max
	unsignedOverflow = unsignedOverflow &+ 1 // unsignedOverflow is now equal to 0

#### Operator methods
	
	struct Vector2D {
			var x = 0.0, y = 0.0
	}

	extension Vector2D {
			static func + (left: Vector2D, right: Vector2D) -> Vector2D {
					return Vector2D(x: left.x + right.x, y: left.y + right.y)
			}
	}

	extension Vector2D {
			static prefix func - (vector: Vector2D) -> Vector2D {
					return Vector2D(x: -vector.x, y: -vector.y)
			}
	}

### Other



### Reference
[Swift](http://www.swift.org)  
