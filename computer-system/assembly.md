## 程序的机器级表示
	了解机器级实现可以:
	1. 知道编译器的优化能力,并分析代码中隐含的低效率.
	2. 知道高级编程语言对我们隐藏的机器实现,避免系统错误.
	3. 编译出的汇编指令,以"."开头的行都是指导汇编器和链接器的命令.

### 数据格式
	* 字(word):16位数据
	* 双字(double words):32位数据
	* 四字(quad words):64位数据

### 访问信息
	一个IA32的CPU包含一组8个存储32位值的寄存器.
	| 32        | 16        | 8        |
	|-----------|-----------|----------|
	| %eax      | %ax       | %ah %al  |
	| %ecx      | %cx       | %ch %cl  |
	| %edx      | %dx       | %dh %dl  |
	| %ebx      | %bx       | %bh %bl  |
	| %esi      | %si       |          |
	| %edi      | %di       |          |
	| %esp      | %sp       | 栈指针   |
	| %ebp      | %bp       | 帧指针   |
	|-----------|-----------|----------|
	
	amd32_64cpu会使2个32位寄存器组成一个64位寄存器,所以32_64CPU可以支持32位系统
	和64位系统.

### 操作数指示符
	操作数(operand):可以有一个或者多个,有三种类型.
	1. 立即数(immediate):也就是常数,表示为$+C表示法表示的整数.
	2. 寄存器(register):表示寄存器的内存,可以根据数据的格式来使用寄存的大小.
	3. 存储器(memory):可以根据计算出来的地址(有效地址)来访问某个存储器的位置.
	   因为地址被看成是一个很大的数组,所以用Mb[Addr]表示.

### 寻址方式
	引用有四个组成部分:
	1. 立即数偏移,Imm
	2. 基址寄存器,Eb
	3. 变址寄存器,Ei
	4. 比例因子,s,取值只能是1,2,4,8.
	5. 有效地址=Imm + R[Eb] + R[Ei] * s
	
	![寻址方式](../img/assembly-img-addressing.png)

### 数据传送指令(最频繁使用的指令)
	* 根据不同的操作类型类型,使用不同的指令.
	* MOV指令是把源操作数的值复制到目的操作数中.
	* 源操作数可以是立即数,或者存储在寄存器中和存储器中.
	* 目的操作数要么是一个寄存器,要么是一个存储器.
	* IA32加了一条限制,2个操作数不能都是存储器.

	* MOVS和MOVZ将一个较小的源数据复制到一个较大的数据位置,高位用符号位扩展(MOVS
	  )或者零扩展(MOVZ)进行填充.

	* pushl popl是对栈的操作,只有一个操作数,数据源和弹出的数据目的.
	  计算机使用程序栈来实现过程调用(函数调用),栈可以实现一个数组,总是从栈顶添加
	  和删除数据,栈在内存中是向下增长的,所以栈顶元素地址是所有栈中元素地址中最低
	  的.

	![数据传送指令](../img/assembly-img-insmov.png)

### 算术和逻辑操作
	* 加载有效地址(load effective address):实际上是movl指令的变形,将有效地址写入
	  到目的操作数.这条指令可以为后面的存储器引用产生指针.(取地址符&)
	* 一元操作数:只有一个操作数,既是源也是目的.如C语言中的++,--.
	* 二元操作数:第二个操作数既是源也是目的.如C语言中的赋值.x += y.
	* 位移操作:位移数可以是立即数,或者放在单字节寄存器%cl中.

	算术和逻辑指令大多不区分有符号和无符号,只有右位移区别算术位移和逻辑位移.

	![算术和逻辑指令](../img/assembly-img-insoperation.png)
	![特殊算术指令](../img/assembly-img-insoperation-special.png)

### 控制
	算术和逻辑操作是根据表达式执行完后状态寄存器中值的组合来判断结果的.

	条件码:
		* CF进位标志:(unsigned) t < (unsigned) a
		* ZF零标志:(t == 0) 最近操作得出的结果为0
		* SF符号标志:(t < 0) 最近操作得出的结果为负数
		* OF溢出标志:( a < 0 == b < 0) && (t < 0 != a < 0)

	除了指令leal不改变条件码,其他的算术和逻辑指令都改变条件码.

	还有一类指令只改变条件码,但不设置值.
	见![比较和测试指令](../img/assembly-img-inscomdition.png)

	访问条件码(不能直接读取):
		1. 可以根据条件码的某个组合,对一个字节设置0或者1.
		2. 可以条件跳转到程序的某个其他的部分.
		3. 可以有条件的传送数据.	
	![SET指令](../img/assembly-img-inscomdition-visit.png)

	跳转指令:
	跳转可以是有条件跳转和无条件跳转,就是是否判断条件码.
	跳转可以是直接跳转和间接跳转,直接跳转是直接指定指令的地址;间接跳转是从寄存器
    与存储器中读出,表示(*(%eax))

	当执行与PC相关的寻址时,程序计数器的值是跳转指令后面的那条指令的地址,而不是
	跳转指令本身的地址.也就是目标地址代码+跳转指令下一条指令的地址=跳转目标地址
	
### 循环
	GCC编译器会先把while for循环转换成do-while的goto形式.
	goto形式都是使用跳转指令.
	
### 条件传送指令
	原始方式是根据条件结果,满足走一条路,不满足走另一条路.条件传送指令是一个替代
	的策略,先计算一个条件操作的两个结果,然后再根据条件结果是否满足选择一个.
	x < y ? a : b

	![条件传送指令](../img/assembly-img-instranfer.png)

	如何确定分支预测错误的处罚时间
	设:预测错误的概率为P,没有预测错误的执行时间为Tok,测试错误的处罚为Tmp,执行平
       均时间为Tavg.
	Tavg(P)=(1-P)Tok+P(Tok+Tmp)=Tok+PTmp,设P为0.5

	Tmp=2(Tavg-Tok)
	![跳转指令](../img/assembly-img-insjump.png)

### 过程
	过程调用是使用栈帧结构来实现的:
		%ebp帧指针,%esp栈指针
		1. 过程使用栈来保存其他不能存放在寄存器中的局部变量.
		2. 调用其他过程前先倒序对传递参数进行压栈.(减%esp)
		3. 调用call命令来实现调用其他过程,可以直接跳转,也可以间接跳转.先保存call
		   指令的下一条指令地址为返回地址,接着跳转到被调用过程.
		4. 被调用过程会先保存%ebp帧指针(调用过程帧的指针),设置新的%ebp(当前的),
		   %esp,保存寄存器与创建局部变量.
		5. 被调用过程处理完成,把返回值存放在%eax中,恢复保存的寄存器,调用leave指
           令为返回做准备(把%ebp %esp恢复成调用前),调用ret返回到调用过程

	递归过程,因为每个调用在栈中都有自己的私有空间,多个未完成调用的局部变量不会相
	互影响,所以可以实现过程自己调用自己.而且过程调用很自然地提供了适当的策略,使
	过程被调用时分配局部变量,过程返回时释放存储.

	寄存器使用惯例:为了确保过程间的调用不会覆盖某个过程的值,需要采用IA32统一的寄
	存器使用惯例,所有过程都必须遵守.
	* 调用者保存寄存器:%eax,%edx,%ecx.
	* 被调用者保存寄存器:%ebx,%esi,%edi.

### 数组分配和访问
	数组被看成是地址连续的存储空间,步长根据数据类型的大小来表示.数组访问是通过指
	针的计算来实现.

	数组嵌套,编译器会以数组起始为基地址,偏移量为索引,产生计算期望的元素的依稀量,
	然后使用某种MOV指令.

	定长数组,编译器能够优化定长多维数组上的操作代码.编译器会判断循环模式,添加中
	间变量,修改计算方式来优化代码.

	变长数组,C99前只能使用malloc与calloc来实现变长数组.C99后支持数组的维度为表达
	式.在循环变长数组中,编译器可以利用模式的规律性来优化索引的计算

	寄存器溢出(register spilling):寄存器不够保存临时数据时,会选择一些局部变量放
	到存储器中.因为读存储器比写存储器容易的多,所以一般把只读的数据溢出到存储器.

### 异质的数据结构
	结构(struct):将不同的数据对象聚合到一个对象中,对象在存储器中连续存储,编译器
	维护关于每个结构类型的信息,指示每个字段的字节偏移.编译器以这些偏移作为存储器
	引用指令中的位移,来访问结构中的元素.

	联合(union):用不同的字段来引用相同的存储器块.联合的总的大小等于它最大字段的
	大小.

	机器代码中缺乏类型信息,无论参数是一个float,还是一个unsigned,他都在相对%ebp偏
    移量为8的地方.当使用联合时,字节顺序问题就变得很重要了.
			
### 数据对齐
	CPU读存储器数据,一次读取是根据数据总线大小来的,一般分为32位,64位.如果一个64
	位double数据是K(根据类型大小分为2,4,8)对齐的,就只用一次读取指令;如果不是K对
	齐就需要2次读取,而读取存储器指令是最常用的指令之一.

	所以为了提高性能,计算机系统对数据类型合法地址做了一个限制,要求某种类型对象的
	地址必须是某个K(2,4,8)值的倍数.

	Linux对short限制必须是2的倍数,对较大的数据类型(int,int*,double)限制必须是4的
	倍数.8字节数据在4字节边界上对齐,在i386中很适用,因为老的机器的存储器接口是4字
	节宽.

	Microsoft Windows要求long long和double类型必须是8的倍数,提高了存储器的性能,
	代价是浪费了一些空间.在现代处理器上,这个策略比较好.

	对多媒体指令SSE,因为每次是读取16字节的长度,如果数据不对齐,该指令会报错.所以
	IA32的一个惯例是,确保每个栈帧的长度都是16字节的整数倍.编译器就可以在栈帧中以
	每个块的存储都是16个字节对齐的方式来分配存储.

	汇编代码声明对齐:  .align 4    后面的元素会遵守4字节对齐的限制. 

	分配存储器的库(malloc),会满足运行机器最糟糕的情况的对齐限制,通常是4或8.

	结构对齐,会在结构中和结构结尾插入空字节来保证4对齐.

### 理解指针
	1. 每个指针都对应一个类型,void* 代表通用指针.
	2. 每个指针都有一个值,NULL(0)代表该指针没有指向任何地方.
	3. 指针用&运算符创建,通常使用leal指令生成.
	4. 操作符用于指针的间接引用.
	5. 数组与指针紧密联系.
	6. 将指针从一种类型强制转换成另一种类型,只改变类型,不改变它的值.
	7. 指针也可以指向函数,int (*f)(int x);

### 使用GDB调试器
	见![GDB调试器](/home/lmf/git/document/img/assembly-img-insgdb.png)

### 编译器优化
	使用GCC和CLANG可以使用优化策略,对C语言源码进行优化,可以显著的提高程序的性能.
	目前Linux应用通常使用-O2来优化.但是优化后的机器代码与源代码之间的映射非常难
	以理解.

	1. 控制结构变得更纠结
	2. 过程调用常常是内联的
	3. 常常用循环来替代递归


