## 信息存储
	字节:最小寻址单位,内存块
	地址:每个内存块的唯一标识
	字:CPU一次处理数据的大小,目前流行32位,64位
	虚拟存储器:计算机和操作系统对存储系统的抽象
	虚拟地址空间:所有可能地址的集合
	
## 进制表示法
	2进制:0,1
	8进制:0~7
	10进制:0~9         前缀0
	16进制:0~9,A~F     前缀0x

	2进制表示太冗长,而且不好读,而2进制和10进制相互转化很麻烦,所以计算机一般
	使用8进制,16进制来表示.多用于16进制.

## 进制间的转换
	2转8:每3位2进制数转成1位8进制数.
	8转2:每1位8进制数转成3位2进制数.
	2转16:每4位2进制数转成1位16进制数.
	16转2:每1位16进制数转成4位2进制数.

	10转2:10进制数除2取余法
	2转10:2进制数按权展开并相加

	10转8:10进制数除8取余法
	8转10:8进制数按权展开并相加

	10转16:10进制数除16取余法
	16转10:16进制按权展开并相加

## 数据大小
	| C声明          | 32位机器 | 64位机器 |
	|----------------|----------|----------|
	| char           | 1        | 1        |
	| short int      | 2        | 2        |
	| int            | 4        | 4        |
	| long int       | 4        | 8        |
	| long long int  | 8        | 8        |
	| char *         | 4        | 8        |
	| float          | 4        | 4        |
	| double         | 8        | 8        |
	|----------------|----------|----------|

	不同机器用不同编译器编译出的程序里,数据大小是不一样的,因为C标准只定义了
	数据大小最小值,而没有确定实际大小.所以不同编译器的实现有可能不一样,为了
	可移植性应使用数据大小不敏感的类型,stdint.h库下面的数据类型

## 字节顺序
	数据都是从低地址开始存储的,保存跨字节的数据时有两种方法:
	大端法(big endian):最高有效位在前面
	小端法(little endian):低有效位在前面,大多数兼容机使用这种
	
	双端法:可以通过配置指定是用大端还是小端
	
	例:0x01234567
	大端法: 01 23 45 67
	小端法: 67 45 23 01

	不同字节顺序会遇到的问题:
	1. 采用不同字节顺序的机器进行网络通信,会造成字节成反序.目前网络应用程序
	   已经遵守字节顺序规则,解决了这个问题.
	
	2. 查看指令时,如果是小端法,那么查看的顺序跟书写数字时的顺序是反的

	3. 强制类型转换时,获取的字节顺序也是不同的

## 字符编码
	
### ASCii编码
	占用一个字节,不使用最高字节,只能表示127个字符

### ISO 8859 N
	ASCii一般英文是够用了,但是拉丁字母就不能表示出来.ISO 8859 就是用的ASCii
	第八位来表示更多的字母.

	* ISO8859-1 字符集，也就是 Latin-1，是西欧常用字符，包括德法两国的字母。
	* ISO8859-2 字符集，也称为 Latin-2，收集了东欧字符。
	* ISO8859-3 字符集，也称为 Latin-3，收集了南欧字符。
	* ISO8859-4 字符集，也称为 Latin-4，收集了北欧字符。
	* ISO8859-5 字符集，也称为 Cyrillic，收集了斯拉夫语系字符。
	* ISO8859-6 字符集，也称为 Arabic，收集了阿拉伯语系字符。
	* ISO8859-7 字符集，也称为 Greek，收集了希腊字符。
	* ISO8859-8 字符集，也称为 Hebrew，收集了西伯莱 (犹太人) 字符。
	* ISO8859-9 字符集，也称为 Latin-5 或 Turkish，收集了土耳其字符。
	* ISO8859-10 字符集，也称为 Latin-6 或 Nordic，收集了北欧的字符。
	* ISO8859-11 字符集，也称为 Thai，它是从泰国的TIS620标准字符集演化而来
	* ISO8859-12 字符集，目前尚未定义。
	* ISO8859-13 字符集，也称为 Latin-7，Baltic
	* ISO8859-14 字符集，也称为 Latin-8, Celtic
	* ISO8859-15 字符集, 也称为 Latin-9,  
	* ISO8859-16 字符集, 正式编号为ISO/IEC 8859-16:2001，又称Latin-10

## 多种类字符编码
	上面字符编码只有一字符,远远不够表示中国汉字.

### GB2312
	字节:两个字节表示,高字节对应94个区,低字节对应94个位.
	编码范围:0101 - 9494 分别加上0xA0就是GB2312编码,0xA1A1 - 0xFEFE
	低127编码叫半角,高127编码叫全角
	
### GBK
	GB2312的扩展,兼容GB2312
	字节:两个字节,8140-FEFE 

### GB18030
	向下兼容GBK和GB2312编码
	字节:单字节,双字节,四字节分段编码方案
	* 单字节
			单字节部分采用GB/T11383的编码结构与规则，使用0x00至0x7F码位
			（对应ASCII码位）。
	
	* 双字节
			双字节部分，首字节码位从0x81至0xFE，尾字节码位分别是
			0x40至0x7E和0x80至0xFE。
	
	* 四字节
			四字节部分采用GB/T11383未采用的0x30到0x39作为对双字节编码扩充
			的后缀，这样扩充的四字节编码，其范围为0x81308130到0xFE39FE39。
			其中第一、三个字节编码码位均为0x81至0xFE，第二、四个字节编码
			码位均为0x30至0x39。

### 统一编码ISO 10646
	Universal Multiple-Octet Coded Character Set,USC
	USC分为USC-2,USC-4.分别是2字节和4字节
	目前版本unicode和usc编码基本上保持了一致
	
### 统一编码UNICODE
	UTF-8:变长字节(1.ASCII,2.希腊字母,3.汉字,4.平面符号)没有字节顺序区分
	UTF-16BE:双字节,大端法
	UTF-16LE:双字节,小端法
	UTF-32:四字节,不常用

	Unicode转换格式(Unicode TransformationFormat，简称为UTF)的方式来编码.
	为了在保存和网络传输中节约空间,UNICODE使用UTF-8的UTF来变长传输.

	Unicode
	UTF-8
	0000 - 007F
	0xxxxxxx
	0080 - 07FF
	110xxxxx 10xxxxxx
	0800 - FFFF
	1110xxxx 10xxxxxx 10xxxxxx

### 编码冲突
	在windows中打开记事本,输入"联通"两个字,保存并关闭.再打开就会出现乱码,这其实
	是因为GB2312和UTF-8编码产生冲突.

	联通的内码是:
	c1 1100 0001
	aa 1010 1010
	cd 1100 1101
	a8 1010 1000
	12和34字节正好与UTF-8汉字编码开头110,10一致,所以记事本误认为是UTF-8编码打开,
	当多写几个字之后,这些字开头不一定是110,10,所以记事本会正常的以GBK打开.

	判断文本编码有三种方式:
	1. 检测文件头标识(常用)
		BOM(byte-order mark，BOM),用来识别文件中使用的编码和字节顺序
		开头字节 Charset/encoding
		EF BB BF UTF-8 
		FE FF UTF-16/UCS-2, little endian 
		FF FE UTF-16/UCS-2, big endian 
		FF FE 00 00 UTF-32/UCS-4, little endian. 
		00 00 FE FF UTF-32/UCS-4, big-endian. 
		如果不是上述的编码,编辑器就会让用户选择

	2. 提示用户选择
	3. 根据一定的规则猜想

### 编码间的转换
	编码之间如GBK和UTF-8在编码上不兼容,所以不能直接转换.工具iconv很好的实现编码
	之间的转换(见:[iconv](http://www.gnu.org/software/libiconv/ "iconv")).

	编码间转换不存在互相变换的算法,只能通过查找表解决转换问题.
	
	在计算机中为了支持不同的编码方式,使用代码页(code page)来处理键盘,输入法等,代
	码页就是字符编码的别名,也叫机内码.是表示当前计算机支持的编码类型.

### 布尔代数
	布尔:使用1和0来表示逻辑真和逻辑假.
	布尔运算:
		* ~0 =1 ;~1 =0
		* 0&0=0;0&1=0;1&0=0;1&1=1
		* 0|0=0;0|1=1;1|0=1;1|1=1
		* 0^0=0;0^1=1;1^0=1;1^1=0
	布尔代数:
		* 0110&1100=0100
		* 0110|1100=1110
		* 0110^1100=1010
		* ~0110=1001
		* 分配律:a&(b|c)=(a&b)|(a&c)
		* 分配律:a|(b&c)=(a|b)&(a|c)
	布尔环(boolean ring):
		对每个整数值x都有一个加法逆元(additive inverse) x+(-x)=0
		在布尔里也有,a^a=0;0^0=1^1=0;a^b^a=b

### 位向量
	位向量[ai,a(i-1),a(i-2)...a2,a1,a0]可以表示A{0,1,....,i-1},其中ai=1当且仅当
	i属于A.如A={0,3,5,6}可以用位向量[01101001]来表示.

	布尔运算|和&对应集合的并和交,而~对就集合的补

### 逻辑运算
	逻辑运算符||,&&,!,对应命题逻辑中的OR,AND,NOT.
	逻辑运算认为所有非0参数都为TRUE,而参数0表示FALSE.运算结果只有0和1.
	按位运算只有在值限定为0和1时,结果与逻辑运算相同.
	逻辑运算如果前面一个参数求值就能确定表达式的结果,那么就不会对第二个参数求值.

### 移位运算
	左移运算(<<):x<<k,丢弃最高的k位,并在右端补k个.位移运算从左至右可结合.
	
	右移运算(>>):x>>k,有两种情况:
		* 逻辑右移:右移在左端补k个0,丢弃最低的k位.
		* 算术右移:右移在左端补k个1,丢弃最低的k位.对有符号数据右移很有用.
	C语言内没有明确定义应该使用哪种类型的右移.对于无符号数据,右移必须是逻辑的.而
	对于有符号数据,逻辑和算术都可以(潜在着可移植性问题).然而几乎所有编译器/机器
	组合都对有符号数据用算术右移,程序员也都假设机器会使用这种右移.

	Java中对位移有明确定义,>>为算术右移,>>>为逻辑右移.	
	
	移动k位,k大于数据位.C语言没有定义这种情况,但是在许多机器上,只会考虑位称是的
	低log2w位,因此实际上位移量就是通过计算k mod w得到的.C语言没有定义,所以结果
	得不到保证,所以要保持移位数量小于字长.

	Java中特别要求位移数据应该按照上面的求模的方法来计算. 
	C和C++都支持有符号和无符号数.Java只支持有符号数.

 
### 整型数表示
	* 无符号数:使用函数B2Uw(Binary to Unsigned)来表示,双射--对于每一个长度为W的
               位向量,都有一个唯一的值与之对应;反过来,在0~2^w-1之间的每一个整数
               都有一个唯一的长度为W的位向量二进制与之对应.
	* 补码编码:有符号数一般用补码形式表示,补码最高有效位解释为负权(negative
	           weight),使用函数B2Tw(Binary to Two's-complement,长度为w)来表示.
		    	
			   补码最小值TMinw:-2^(w-1),位向量设置位为负权,清除其他所有位.
			   补码最大企TMaxw:2^(w-1)-1,清除负权位,设置其他所有位.
			   B2Tw也是一个双射.

			   补码=原码==>反码+1
			   原码0=00000000,-0=1000000;反码0=00000000,-0=11111111
			   0补码=00000000
			
			   正数:原码=反码=补码
			   负数:原码=反码(除负权位外,按位取反)=补码(反码加1)
	
	为什么用补码:
			1. 避免判断符号位使硬件设计过于复杂,并且符号位可以参加运算.
			2. 可以使用加法来实现算术运算中的加和减.
			3. 避免原码+0和-0的不同,0就是00000000,而10000000可以表示成-128(-128
               因为是使用-0的表示所以没有对应的原码和反码,-1-127=-128).
			
	为什么补码可以用加法来替代减法:
			1. 同余:两个整数a,b,若它们除以整数m所得的余数相等,则称a,b对于模m同余
			2. 负数取模:x<0,x mod y 等于x减去y乘上x与y的商的下界.
			3. (-2)与10对于模12同余,(-4)与8对于模12同余.
			4. 如果a与b对于模m同余,并且c与d对于模m同余,那么a+-c与b+-d对于m同余;
			   a*c与b*d对于m同余.
			5. 7-2与7+10对于模12同余.
			6. 2-1=1 ==> 2+(-1)= [00000010]原+[10000001]原=[00000010]反+
			   [11111110]反
			7. -1反码如果认为是原码就是-126,除去符号位就是126.
			8. 发现(-1) mod 127 = 126; 126 mod 127 = 126;
			9. 2-1与2+126对于127同余,而余数是相等为1.正好是2-1的结果
			0. 所以说一个数的反码,实际上是这个数对于一个模的同余数.而这个模并不
			   是我们的二进制,而是所能表示的最大值.相当与钟表转了一圈.

### 强制类型转换
	数值可能会变,但是位模式不变.
	无符号转有符号:U2Tw(x)=B2Tw(U2Bw(x))
	有符号转无符号:T2Uw(x)=B2Uw(T2Bw(x))
	有符号数与无符号数关系:B2Uw(T2Bw(x))=T2Uw(x)=xw-12^w+x
	无符号数与有符号数关系:B2Tw(U2Bw(u))=U2Tw(u)=-uw-12^w+u

	C语言计算时的隐式类型转换:
		如果一个运算数是有符号的,另一个是无符号的,那么C语言会隐地将有符号参数强
		制类型转换为无符号数.

	扩展一个数字的位表示:
		* 零扩展:开头添加0,一般用于无符号
		* 符号扩展:开头添加最高有效位,一般用于有符号
		  B2Tw+1([xw-1,xw-1,xw-2,...,x0])=B2Tw([xw-1,xw-2,...,x0])
		  2^w-2^w-1=2^w-1

	截断数字:
		无符号表示:B2Uk([xk-1,xk-2,....,x0])=B2Uw([xw-1,xw-2,...,x0]) mod 2^k.
		补码数字:B2Tk([xk-1,xk-2,...,x0])=U2Tk(B2Uw([xw-1,xw-2,...,x0]) mod 2^k)
		
### 整数运算
	1. 无符号加法:0<=x+y<=2^(w+1)-2,可能需要w+1位来表示.如果是固定精度就需要丢弃
	   精度,可以被视为一种模运算形式,x+y mod w.阿贝尔群,它有一个单位元0,并且每个
	   元素有一个加法逆元,(x + 2^w-x) mod 2^w = 0.
	
	2. 补码加法四种情况:
			* 负溢出(negative overflow)2个负数相加得到一个正数
			* 正常数:负数
			* 正常数:正数
			* 正溢出(positive overflow)2个正数相加得到一个负数
	
	3. 补码的非计算有两种方式:
			* 先求补,再加一
			* 取最右边1为基准,基准左边所有位取反

	4. 无符号乘法:x*y mod 2^w
			
	5. 补码乘法:x * y = U2T((x * y) mod 2 ^ｗ)
	   无符号和补码乘法运算是同构的,在位级上有相同的结果.

	6. 乘以常数,在大多数机器上,整数乘法指令相当慢,需要10个或者更多的时钟周期.而
	   其他的整数运算(如加法,减法,位级运算和位移)只需要1个时钟周期.所以编译器会
	   使用加法和位移运算来实现乘法. 
	   x * 14 = (x<<3) + (x<<2) + (x<<1)= (x<<4)-(x<<1)

	7. 除2的幂,整数除法比整数乘法更慢,要30多个时钟周期.我们可以使用右移运算来计
	   算除法.

	8. 整数运算就是位模式运算,表示数字的有限长度限制了值的取值范围,结果运算可能
	   会溢出.整数运算中的值不管是有符号,还是无符号,他们的位模式是一样的或非常相
	   似.

### 二进制小数表示
	10进制小数可以表示为   12.34 = 1 * 10^1 + 2 * 10^0 + 3 * 10^-1 + 4 * 10^-2
	2进制小数表示为   11.11 = 1 * 2^1 + 1 * 2^0 + 1 * 2^-1 + 1 * 2^-2

	小数的精度跟表示数的长度有关
	定点表示法,不能表示非常大的数字如 5 * 2^100 
	
	
### IEEE浮点表示
	V = (-1)^s * M * 2^E

	符号(sign) s:决定这个数是负数还是正数
	尾数(significand) M:是一个二进制小数,它的范围是1~2-e或者0~1-e
	阶码(exponent) E:对浮点数加权  (移动小数点)

	对三个部分进行编码:
		* 一个符号位s编码符号s
		* k位阶码字段exp编码阶码E
		* n位小数字段frac编码尾数M

	float(32位):s=1 k=8 n=23
	double(64位):s=1 k=11 n=52

	被编码的值可以分成三种不同的情况:
		1. 规格化:阶码!=0 && != 255  表示一个正常的小数
		2. 非规格化:阶码==0,可以表示+0.0和-0.0;还可以表示一个非常接近0.0的数
		3. 特殊值:阶码==255,尾数=0时,S=0表示正无穷,S=1表示负无穷;尾数不=0时,表示
		   NAN(not a number).运算的结果不能是实数或无穷时,表示NAN

	
### 浮点数舍入
	因为表示方法限制了浮点数的范围和精度,浮点运算只能近似地表示实数运算.因此,对
	于一个实数值,我们需要找到最接近的数,这就是舍入.舍入有4种方式,一种方式是默认
	方式,找到最接近的数.其他3种确定边界.
	
	1. 向偶数舍入(默认):向上或向下舍入,使最后一位数为偶数

	2. 向零舍入:正数向下,负数向上

	3. 向下舍入:正负数都向下

	4. 向上舍入:正负数都向上

		
### 浮点数运算
	IEEE对浮点数去处指定了简单的规则,可以独立于任何具体的硬件或者软件.

	1/0=正无穷 1/-0=负无穷

	浮点单元计算不能完全的计算,只会计算到可以保证得到一个正确的舍入结果就可以.所
	以浮点运算是可交换,不可结合的.

	(3.14 + le10) - le10 = 0  而3.14 + (le10 - le10)=3.14

	实数加法也形成阿尔贝群,但是无穷和NAN除外,正无穷+负无穷=NAN,任何数+NAN=NAN

	IA32以前是用80位扩展寄存器来计算单双浮点数,所以在转换的过程中由于舍入,上溢,
	下溢可能改变他的值.现代处理器会改正这一点.

	

