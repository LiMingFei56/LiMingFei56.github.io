---
layout: page
permalink: /program-language/c/memory-model
---

Memory Model

### 名称空间
命名空间是为了解决 “在相同作用域内如何区分相同的标识符”。说明：
1. 只有在相同作用域的情况下才能使用到命名空间去区分标识符，在嵌套的作用域、不同的作用域区分标
    识符都用不到命名空间的概念。
2. 在相同的作用域内，如果命名空间不同，标识符可以使用相同的名称。否则，即如果命名空间相同同
    ，编译器会报错，提示重复定义。

按照C99（章节6.2.3），命名空间可以分为四种：
1. 所有的标签（label）都属于同一个命名空间。 说明：1在同一个函数内，你的标签不能相同。
    2在同一个函数内，标签可以和其他变量名称相同。因为它们所属的命名空间不同。

2. struct、enum和union的名称，在C99中称之为tag，所有的tag属于同一个命名空间。 也就是说
    ，如果你已经声明struct A { int a }; 就不能在声明 union A{ int a };说明：之所以让所有
    的tag组成一个命名空间，由于Tag前面总是带struct，enum或union关键字，所以编译器可以将
    它们与其他的标识符区分开。

3. struct和union的成员属于一个命名空间，而且是相互独立的。例如：如果你已经声明struct A 
    { int a };其成员的名称为a，你仍然可以声明 struct B{ int a };或者union B{ int a }
    ; 说明：之所以让struct和union的成员各自成为一个命名空间，是因为它们的成员访问时
    ，需要通过 "."或"->"运算符，而不会单独使用，所以编译器可以将它们与其他的标识符区分开
    。由于枚举类型enum的成员可以单独使用，所以枚举类型的成员不在这一名称空间内。

4. 其他所有的标识符，属于同一个名称空间。包括变量名、函数名、函数参数，宏定义、typedef的类
    型名、enum的成员 等等。注意：如果标识符出现重名的情况，宏定义覆盖所有其它标识符，这
    是因为它在预处理阶段而不是编译阶段处理。除了宏定义之外其它类别的标识符，处理规则是
    ：内层作用域会隐藏掉外层作用域的标识符。

### 作用域

1. 代码块作用域（block scope）：在代码块中定义的变量，函数定义的形参
2. 函数原型作用域（function prototype scope）：适用于函数原型中使用的变量名，如
    int mighty(int mouse, double large)；从变量定义到声明末尾。编译器只关注参数类型，不关注参数名。
3. 文件作用域（file scope）：从定义到包含定义的文件结尾
4. 函数作用域（function scope）：只适用于goto语句使用的标签

### 链接

1. 外部链接（external linkage）：文件作用域，该变量可以在多个文件程序的任何地方使用
2. 内部链接（internal linkage）：文件作用域，使用static修饰，可以在定义的文件中任何地方使用
3. 空链接（no linkage）：代码块或函数原型作用域

### 存储类

* auto - 自动——在一个代码块内（或在一个函数头部作为参量）声明的变量，无论有没有存储类型修饰符auto
    ，都属于自动存储类。该类具有自动存储时期、代码作用域和空链接。如未经初始化，它的值是不定的。
* register - 寄存器——在一个代码块内（或在一个函数头部作为参量）使用存储类修饰符register声明的变
    量属于寄存器存储类。该类具有自动存储时期、代码作用域和空链接，而且无法获得其地址。把一个变量
    声明为寄存器变量可以指示（建议）编译器提供可用的最快访问。如未经初始化，它的值是不定的。
* static - 静态、空链接——在一个代码块内使用存储类修饰符static声明的变量属于静态空链接存储类。
    该类具有静态存储时期、代码作用域和空链接，仅在编译时初始化一次。如未明确初始化，它的字节都被设定为0。
* static - 静态、外部链接——在所有函数外部定义、未使用存储类修饰符static声明的变量属于静态
    、外部链接存储类。该类具有静态存储时期、代码作用域和外部链接，仅在编译时初始化一次
    。如未明确初始化，它的字节都被设定为0。
* static - 静态、内部链接——在所有函数外部定义、使用存储类修饰符static声明的变量属于静态、内部链接
    存储类。该类具有静态存储时期、代码作用域和内部链接，仅在编译时初始化一次。如未明确初始化
    ，它的字节都被设定为0。

### 分配内存 
分配内存是使用函数malloc()（或相关的函数）提供的内存，该函数返回一个指向具有所请求字节数的内存块的指针。
将这一个内存块的地址作为参数来调用函数free()，可以使该内存块重新可用。


* 说明符const将数据设定为不变的。在使用指针时，const可以表明指针本身不变或指针指向的数据不变，
    这取决于const在声明中的位置。
* 说明符volatile表明数据除了可被程序修改外还可以通过其他方式修改，其目的是警示编译器在优化时
    不要做出相反的假设。
* 说明符restrict也是为了优化而设置。由restrict限定的指针被认为是提供了对其所指向的数据块的惟
    一访问途径。

### 旧关键字的新位置（C99）
C99允许将类型限定词和存储类限定词static等放在函数原型和函数头部的形式参量所属的初始方括号内。
对于类型限定词的情形，这样做为已有功能提供了一个可选语法。例如，下面是一个使用旧语法的声明：

    void ofmouth (int * const a1, int * restrict a2, int n); // 以前的风格

它表明a1是一个指向int的const指针，a2是一个受限指针。等价的新语法如下：

    void ofmouth (int a1[const], int a2[restrict], int n); // C99允许

static的情形是不同的，因为它引发了一些新问题。例如，考虑如下原型：

    double stick (double ar[static 20];

使用static表明在函数调用中，实际参数将是一个指向数组首元素的指针，该数组至少具有20个元素
（即使用“static n”来表示保证至少有n个元素）。这样做的目的是允许编译器使用这个信息来优化函数的代码。

和restrict相同，关键字static有两个读者。一个是编译器，它告诉编译器可以自由地做一些有关优化的假定
。另一个是用户，它告诉用户仅使用满足static要求的参数（至少有所保证个数的元素）。
