---
layout: page
permalink: /program-language/c/effective
---

Effective

程序有些问题可以由编译时识别出来，而有些问题编译可以通对，但是运行时与结果不同。

### Declaration And Definition

definition - 只能出现在一个地方，确定对象的类型并分配内存，用于创建新的对象
declaration - 可以多次出现，描述对象的类型，用于指代其他地方定义的对象

声明的优先级规则
A 声明从它的名字开始读取，然后按照优先级顺序依次读取
B 优先级从高到低依次是：
    B. 1 声明中被括号起来的那部分
    B. 2 后缀操作符：
           括号()表示这是一个函数，面方括号[]表示这是一个数组
    B. 3 前缀操作: 星号*表示"指向...的指针"
C 如果const和(或)volatile关键字的后面紧跟类型说明符(如int,long)等,那么它作用于
  类型说明符。在其他情况下，const和(或)volatile关键字作用于它左边紧领的指针星号。

### 数组与指针

    int a[];
    int *y = a;

数组a，是数组的首地址，指向下标为0的元素；
指针y，是指向数组首地址的地址。

所以一般情况下数组和指针不同，需要声明和定义匹配

什么情况下相同：
* 规则1 表达式中的数组名（与声明不同）被编译器当作一个指向该数组第一个元素的指针
* 规则2 下标总是与指针的偏移量相同
* 规则3 在函数参数的声明中，数组名被编译器当作指向该数组第一个元素的指针


### typedef 与 define
typedef定义一个类型别名，编译使用
define声明一个替换宏，预处理器使用

    #define int_ptr int *
    int_ptr chalk, cheese;

    chalk 和 cheese是两种不同的类型，chalk是指向int的指针，而cheese是int

### 词法
程序语言中的*token*相当于句子中的单词，符号是程序中的一个基本信息单元。而组成符号的
字符序列就不同，同一组字符序列在不同的上下文环境中属于不同的符号。

#### 词法分析中的贪心法
C语言中有些符号是由多个字符组成，C语言使用贪心法来处理分析多字符组成的符号。每一
个符号应该包含尽可能多的字符。但是其中不能有空白，符号是由空白来分隔的。

* = 不同于 ==
* &和|不同于&&和||
* 整型常量，0和0x
* 字符与字符串，单引号引用的是整数；字符串引用的是字符数组起始指针。字符串尾部要添加'\0'。

### 语法
理解符号是怎么组成声明、表达式、语句和程序。

* 理解函数声明
	任何变量都有两个部分组成：类型和一组类似表达式的声明符。
	
	(*(void(*)())0)();
	
	float f, g; // 声明2个float类型的变量
	float ((f)); // 因为第二部分声明符与表达式类似，所以可以任意使用括号
	float ff(); // 声明一个返回值为float的函数
	float *pf; // 声明一个指向float类型变量的指针
	float *g(),(*h)(); // g是一个函数，返回值类型为指向float类型的指针；h是一个指向返回值为float类型的函数。
	(float (*)());// 表示"指向返回值为float类型的函数的指针"的类型转换符。
	(*fp)();//调用一个指向函数的指针

* 运算符的优先级问题，如果第一眼看不清楚优先级，应该使用括号来表明
* 注意分号，某些语句后多一个分号，少一个分号意思完成不一样
* switch语句的"fall although"
* 函数调用（）；
* "悬挂"else，else总是与最近的同级的if相结合

### 语义
一个句子哪怕其中的每个单词都拼写正确，而且语法也无懈可击，仍然可能有歧义或者并非书写者希望表达的
意思。

#### 指针与数组
1. C语言中只有一维数组，而且数组的大小必须在编译期就人作为一个常数确定下来。而且数组的元素类型可以是任何类型。
2. 对一个数组，我们只能够做两件事：确定该数组的大小，以及获得指向该数据下标为0的元素的指针。

给一个指针加上一个整数，与给该指针的二进制表式加上同样的整数，两者的含义截然不同。

#### 非数组指针


#### 作为参数的数组声明
在C语言中，我们没有办法可以将一个数组作为函数参数直接传递，如果使用数组名作为参数，那么
数组名会立即被转换成指向该数组第1个元素的指针。

#### 避免“举隅法”

“举隅法”(synecdoche)：以含义更宽泛的词语来代替含义相对较窄的词语，或者相反。

#### 空指针并非空字符串
NUL定义为结束一个ASCII字符串
空指针是指向地址为0的指针，无意义。一般定义为NULL

#### 边界计算与不对称边界
数组下标从0开始，如果定义一个int[10]，那么下标是从0~9.
而10就是数组下标的上边界。

要坚持遵循“不对称边界”的原则：比较上边界，我们要比较数组后第一个字符的地址。我们不需要引用它的元素，只需要
获取地址的值。

	if (bufptr == &buffer[N]) 代替 if ( bufptr > &buffer[N - 1])

#### 整数溢出
2个操作数都是有符号整数时，就有可能发生溢出，而溢出的结果是未定义的。将操作数转换成无符号然后比较整数最大值，才能
判断是否发生溢出。

#### 为函数main提供返回值
C语言函数如果不设置返回类型，那么默认为int型，操作系统认为0为程序执行成功，其他值为执行失败。
函数如果在被调用前没有定义或声明，那么返回值也是默认为int类型。


### 连接

#### 声明和定义
一般在头文件中定义外部变量，在使用这个变量的地方声明外部变量。不能在一个程序中，对变量定义2次。
在一个程序中定义多次同一名字的变量，就存在命名冲突问题。可以使用static关键字，把变量和函数限止在当前源文件中使用。

#### 形参、实参与返回值
返回值如果不声明和定义，那么会使用默认的int类型，如果int类型与实际的类型不一至，那么连接会出错。
形式参数如果不是float,short,char类型，那么声明时可以省略参数列表。short和char自动转换成int，float自动转换成double。
但是不支持这样做。


#### 头文件
对一个外部变量对象，要保证类型一致。

在头文件中声明外部变量，并且定义该外部对象的模块也应该包括这个头文件

### 库函数

#### 确定库函数返回值类型
不要用比返回值类型范围小的类型来接收返回值。

#### 使用errno检测错误
很多库函数，特别是那些与操作系统有关的，当执行失败时会通过一个名称为errno的外部变量，通知程序该函数调用失败。

/* 调用库函数 */
if (返回的错误值)
	检查 errno

### 预处理器

* 不能忽视宏定义中的空格，空格不一样，代表的宏定义也不一样
* 宏并不是函数，宏的值有副作用，然而展开后会很长
* 宏并不是语句，展开后可能使代码原意不同
* 宏并不是类型定义，最好使用typedef

### 可移植性
* 应对c语言标准变更
* 标识符名称的限制，大小写的区分等
* 整数的大小，在不同平台上内置类型的实现大小可能不一样
* 有符号数和无符号数，编译器在转换char类型到int类型时，需要做出是用有符号解释，还是无符号。
* 移位运算符，是以逻辑位移，还是算术位移
* 内存位置0
* 除法运算时发生的截断
* 首先释放，然后重新分配内存

### 建议
* 不要说服自己相信“皇帝的新装”
* 直截了当地表明意图
* 考查最简单的特例
* 注意潜伏在暗处的Bug
* 防御性编程
