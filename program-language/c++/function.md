---
layout: page
permalink: /program-language/c++/funcation
---

Funcation

使用`constexpr`修饰函数，告诉函数编译期间有可能计算出值。

### 临时变量、引用参数和const
    如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才
允许这样做，但以前不是这样。

### 重载解析(overloading resolution)
重载解析 - 对于函数重载、函数模板和函数模板重载提供一个选择策略，来决定函数调用使用哪一个
    函数定义。

#### 解析步骤

1. 创建候选函数列表。其他包含与被调用函数的名称相同的函数和模析函数。
2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，
    其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将
    该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。
3. 确定是否有最佳有可行函数，如果有，则使用它，否则该函数调用出错。

#### 从最佳到最差的顺序

1. 完全匹配，但常规函数优先于模板
    * 指向非const数据的指针和引用优先与非const指针和引用参数匹配（void recycle(blot &)优
        先与void recycle(const blot &) ，这种只试用与指针与引用）。
    * 非模板函数将优先于模板函数（包括显式具体化）
2. 提升转换（如char和shorts自动转换为int，float自动转换为double）
3. 标准转换（如int转换为char，long转换为double）
4. 用户定义的转换，如类声明中定义的转换

第一步 - 寻找最匹配的函数
第二步 - 多个最匹配的函数，选择非模板函数
第三步 - 没有非模板函数，选择更具体的函数
第四步 - 报错

### 查找函数
1. 函数原型如果是static，就在当前文件中寻找
2. 否则，所有文件中寻找，如果找到多个将发出错误消息
3. 在库中搜索

### 语言链接性 Language Linking
C++中支持函数的重载，所以不能使用C语言的LL，必须将重载的函数翻译为不同的符号名称。
因此，C++编译器执行名称矫正或名称修饰，spiff(int)转换为_spiff_i，而spiff(double, double)
转换为_spiff_d_d，为种方法叫作C++语言链接性。

### Funcation override And overland
C++中函数重写就是在子类中重新定义父类的函数，函数名和参数列表要求一样。但是把子类对象
赋值给父类型指针，函数调用还在父类的。为了实现多态，允许父类指针来调用子类的函数，就
要使用虚函数实现动态单分派子类型多态(dynamic single-dispatch subtype polymorphism)。

函数重载要求参数列表不一样(参数个数和参数类型)

### 静态联编和动态联编
程序调用函数，将使用哪个可执行代码块呢？编译器负责回答这个问题。将源代码中的函数调用
解释为执行特定的函数代码块被称为函数联编(`binding`)，编译器必须查看函数参数以及函数名，
唯一确定使用哪个函数。

静态联编(static binding)，又叫早期联编(early binding) - 在编译过程中进行联编
动态联编(dynamic binding)，又叫晚期联编(late binding) - 虚函数，使编译器生成能够在程序运行
    时选择正确的虚方法的代码

默认为静态联编，出于效率和概念模型。

#### 指针和引用类型的兼容性
C++中不允许使一个类型的对象，赋值给另一个类型。但是继承除外，is-a关系中有部分叫向上
强制转换(upcasting)，将派生类引用或指针转换为基类引用或指针，这使公有继承不需要进行显
式的类型转换。

相反的过程-把基类的指针或引用转换成派生类的指针或引用，必须显式的使用强制类型转换，这叫
做向下强制转换(downcasting)

#### 虚函数的工作原理
给每个对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为
虚函数表(virtual function table vtbl)。vtbl中存储了为类对象进行声明的虚函数地址。

1. 派生类初始vtbl包含基类所有虚函数的地址
2. 如果派生类实现了自己的虚函数，就会更新vtbl对应函数地址，指向新函数

#### 虚函数注意事项
* 在基类方法的声明中使用关键字`virtual`可使该方法在基类以及所有的派生类中是虚的
* 如果使用指针或引用调用虚函数，将使用动态联编
* 需要把子类需要重写的函数定义为`virtual`
* 构造函数不能是`virtual`
* 析构函数应当是`virtual`
* 友元不能是`virtual`
* 可以使用基数限定符调用基类非私有方法 Base::call();

使用override修饰虚函数声明，必须定义(编译器会检查函数的特征码是否一样)，如果特征
码不一样就不会覆盖基类虚函数，而是隐藏。

    virtual void f(char * ch) override;

使用final修饰虚函数声明，不允许被覆盖

    virtual void f(char ch) final {....};

### 函数对象
重载运算符`()`来实现函灵敏对象，也叫函数值。可以像调用函数一样使用对象。

* 生成器（generator）是不用参数就可以调用的函数符
* 一元函数（unary function）是用一个参数可以调用的函数符
* 二元函数（binary function）是用两个参数可以调用的函数符

* 返回bool值的一元函数是谓词（predicate）
* 返回bool值的二元函数是二元谓词(binary predicate)

自适应函数符
adaptable


### Lambda函数
Lambda calculus - 一种定义和应用函数的数学系统，这个系统可以让您能够使用匿名函数。仅
当lambad表达式完全由一条返回语句组成时，自动类型推断才管用；否则，需要使用返回类型
后置语法：

    [](double x) -> double {int y = x; reutrn x -y;}

    [&count](int x){count += (x % 13 == 0);}

    [] 为函数名，中间可以捕获动态变量，代码块中可以使用;[=]捕获所有动态变量的值；
        [&]捕获所有动态变量的引用
    () 主参数列表
    {} 为代码码，返回值为dealtype自动推断，如果没有返回值就返回void

