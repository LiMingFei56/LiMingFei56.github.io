---
layout: page
permalink: /program-language/c++/funcation
---

Funcation

### 临时变量、引用参数和const
    如果实参与引用参数不匹配，C++将生成临时变量。当前，仅当参数为const引用时，C++才
允许这样做，但以前不是这样。

### 重载解析(overloading resolution)
重载解析 - 对于函数重载、函数模板和函数模板重载提供一个选择策略，来决定函数调用使用哪一个
    函数定义。

#### 解析步骤

1. 创建候选函数列表。其他包含与被调用函数的名称相同的函数和模析函数。
2. 使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，
    其中包括实参类型与相应的形参类型完全匹配的情况。例如，使用float参数的函数调用可以将
    该参数转换为double，从而与double形参匹配，而模板可以为float生成一个实例。
3. 确定是否有最佳有可行函数，如果有，则使用它，否则该函数调用出错。

#### 从最佳到最差的顺序

1. 完全匹配，但常规函数优先于模板
    * 指向非const数据的指针和引用优先与非const指针和引用参数匹配（void recycle(blot &)优
        先与void recycle(const blot &) ，这种只试用与指针与引用）。
    * 非模板函数将优先于模板函数（包括显式具体化）
2. 提升转换（如char和shorts自动转换为int，float自动转换为double）
3. 标准转换（如int转换为char，long转换为double）
4. 用户定义的转换，如类声明中定义的转换

第一步 - 寻找最匹配的函数
第二步 - 多个最匹配的函数，选择非模板函数
第三步 - 没有非模板函数，选择更具体的函数
第四步 - 报错

### 查找函数
1. 函数原型如果是static，就在当前文件中寻找
2. 否则，所有文件中寻找，如果找到多个将发出错误消息
3. 在库中搜索

### 语言链接性 Language Linking
C++中支持函数的重载，所以不能使用C语言的LL，必须将重载的函数翻译为不同的符号名称。
因此，C++编译器执行名称矫正或名称修饰，spiff(int)转换为_spiff_i，而spiff(double, double)
转换为_spiff_d_d，为种方法叫作C++语言链接性。

### Funcation override And overland
C++中函数重写就是在子类中重新定义父类的函数，函数名和参数列表要求一样。但是把子类对象
赋值给父类型指针，函数调用还在父类的。为了实现多态，允许父类指针来调用子类的函数，就
要使用虚函数实现动态单分派子类型多态(dynamic single-dispatch subtype polymorphism)。

函数重载要求参数列表不一样(参数个数和参数类型)
