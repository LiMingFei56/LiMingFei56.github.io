## 泛型
kotlin也支持泛型,可以使用类型参数.

	class Box<T>(t: T) {
		var value = t
	} 

在使用的时候需要提供类型参数:

	val box: Box<Int> = Box<Int>(1)

如果类型参数可以从构造函数参数中或其他地方推断出来,那么可以省略类型参数:

	val box = Box(1) // 1 has type Int, so the compiler figures out that we are
	talking about Box<Int>

### 1. Variance
Java中的通配符,Kotlin中不支持,反而支持`declaration-site variance`和` type
projections`.

Java中泛型是不变的,意味着List<String>不是List<Object>的子类型.
如果泛型类型是可变的话,那么List<String>对象可以赋值给List<Object>,那么Int类型可
以添加到List<Object>中,而List<String>取这个Int对象时会报错.

由此可以看addAll(Collection<E> items)函数,如果泛型是不变的那么List<Object>.addAll
(List<String>)不被允许,但是这个操作是类型安全的.

所以`void addAll(Collection<? extends E> items);`就要这样定义

#### 1.1. 协变(Covariant)
通配符`<? extends E>`的意思是传入的类型与E类型相同,或者是E的某个子类型.这意味着
我们可以使用E类型来读取元素(元素是E类型或E的子类型),但是不能写入对象(因为不知道
哪些类型对象是未知的E类型或其子类型).

	List<? extends Object> objs = new ArrayList<String>();
	如果可以添加的话就可以添加Int对象.这样的话就会报错.

这样的话使得List<String>是List<? extends Object>的子类弄.这种通配符可以限定上边
界,叫作类型的协变(Covariant).

如果我们要从集合中取对象,那么String可以看成是Object来读取.

#### 1.2. 逆变(Contravariance)
如果我们要把对象放入集合中,那么一个Object集合可以放入String对象.
在Java中我们有List<? super String> 是List<Object>的超类.
下边界通配符叫作逆变.

在List<? super String>中,只能调用参数是String的方法(如add(String), 
set(i, String)),如果调用得到值的函数,那么返回的不是String,而是Object.

Joshua Bloch 把只从集合中读取对象,那么叫生产者(Producers),把只把对象写入到集合中
叫消费者(Consumers)

	PECS stands for Producer-Extends, Consumer-Super.

注意:List<? extends E>上不能调用add()和set()函数,但不意味着不变.因为可以调用
clear(),通配符只保证类型安全.而不是数据的不变性.


### 2. declaration-site variance
在Kotlin中没有通配符,但是有一种情况,如果有一个没有消费函数(consumer-methods),那
么Source<Object> objects = Source<String>是安全的,但是编译不知道.在Java中使用通
配符,而在Kotlin中使用"out"关键字来告诉编译器处理.

out就是协变.

int就是逆变.

### 3. Type projections
类型投影就是函数参数的out和in的使用方法.
参数被标记为<out T>就只能取.
参数标记为<in T>时,传入的参数就被限制为T的超类.

	疑问?

### 4. Star-projections
有时候对类型参数是未知的,但是还是要安全使用,那么使用通用类型投影:使用"<*>"

	- Foo<out T>,是T的协变,有个上边界TUpper,Foo<*>相等于Foo<out TUpper>,意思是当
	  T不知道是什么类型时,可以安全从Foo<*>读出TUpper
	- Foo<in T>,是T的逆变,有个下边界,Foo<*>相等于Foo<in Nothing>,意思是当T未知时
	  没有任何类型对象可以安全的放入
	- Foo<T>,是一个不变的有上边界的类型TUpper,等同与Foo<out TUpper>和Foo<in
	  Nothing>.

如果通用类型有多个,那么可以独立的定义每个通用类型为星投影,假设有一个接口定义:
	
	interface Function<in T, out U>

	- Function<*, String> means Function<in Nothing, String>;
	- Function<Int, *> means Function<Int, out Any?>;
	- Function<*, *> means Function<in Nothing, out Any?>.

星投影非常像JAVA的原始类型,但是是安全的.

### 5. 函数的泛型使用
通用类型定义在函数名的前面.

	fun <T> singletonList(item: T): List<T> {
	    // ...
	}
	
	fun <T> T.basicToString() : String {  // extension function
	    // ...
	}

使用包含泛型的函数需要在函数名后面指定类型:

	val l = singletonList<Int>(1)

### 6. 泛型的约束
可以替代给定类型参数的所有可能类型的集合可能受到通用约束的限制。

最常见的泛型为上边界:
	
	fun <T : Comparable<T>> sort(list: List<T>) {
		// ...
	}

T : E  同   ? extends E     T只能是E类型的子类型

默认的上边界是Any?,一个"<>"里只能有一个上边界.

如果一个类型参数需要多个上边界,那么需要一个单独的where子句:

	fun <T> cloneWhenGreater(list: List<T>, threshold: T): List<T>
	    where T : Comparable,
	          T : Cloneable {
	  return list.filter { it > threshold }.map { it.clone() }
	}
