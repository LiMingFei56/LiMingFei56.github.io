## 扩展
跟c#和gosu一样,kotlin提供扩展功能,不用修改类的内部实现,不用继承类和使用任何类型
的设计模式,如装饰.kotlin支持扩展函数和扩展属性.

### 1. 扩展函数
扩展函数需要一个接收类型,也就是需要扩展的类型.如MutableList<Int>类添加swap函数:

	fun MutableList<Int>.swap(index1: Int, index2: Int) {
	    val tmp = this[index1] // 'this' corresponds to the list
	    this[index1] = this[index2]
	    this[index2] = tmp
	}

this关键字就是接收类型的当前对象,这样我们就可以在任何MutableList<Int>类型的对象
上调用swap函数.

	val l = mutableListOf(1, 2, 3)
	l.swap(0, 2) // 'this' inside 'swap()' will hold the value of 'l'

也可以使用泛型来让swap通用.

#### 1.1. 扩展函数是静态分配的
扩展函数不会修改被扩展的类,定义一个扩展并不需要添加一个新成员到类中,而仅仅是使用
这个类型的变量的"."操作符来调用新的函数.

扩展函数是静态分派的,也就是说他们不是出接收者类型来实现的.这意味着被调用的扩展函
数是由调用函数的表达式的类型决定的,而不是在运行时对表达式求值的结果.如:

	open class C

	class D: C()
	
	fun C.foo() = "c"
	
	fun D.foo() = "d"
	
	fun printFoo(c: C) {
	    println(c.foo())
	}
	
	printFoo(D())
会打印"c",因为调用扩展函数的对象类型是C.

如果一个类有一个成员函数和一个扩展函数,并且2个函数的函数名和参数列表相同,那么总
是会调用成员函数.但是扩展函数可以重载成员函数,参数列表不同.

#### 1.2. 可空的接收者类型
定义接收者类型时,可以定义成可空类型(`fun Any?.toString(): String`),所以不管对象
是否为空都可以调用该函数.使用"`this == null`"来判断对象是否为空.

### 2. 扩展属性
kotlin支持扩展属性,由于扩展属性并不会将成员插入到类中,所以扩展属性没有一个支持字
段.因此初始化器并不允许扩展属性初始化,只能显式的使用getter/setter来实现行为.

	val <T> List<T>.lastIndex: Int
	    get() = size - 1

### 3. 伴生对象
如果一个类是一个伴生对象,那么也可以支持扩展函数和扩展属性.只是接收者类型定义时要
带上主类型,如:

	class MyClass {
	    companion object { }  // will be called "Companion"
	}
	
	fun MyClass.Companion.foo() {
	    // ...
	}

就像普通的伴生对象的成员,可以支持使用主类型的类名来调用:

	MyClass.foo()

### 4. 扩展的作用范围
一般情况我们在包的顶级定义,如果在外面使用该扩展,需要使用import来导入.

### 5. 定义扩展成员
可以在一个类个定义另一个类的扩展函数和扩展方法,这种情况会有多少隐藏接收者,对象成
员可以在没有限定符的情况下被访问.

声明扩展函数或属性的类叫分派接收者.
被扩展的类叫扩展接收者.

如果分派接收者和扩展接收者之间发生命名冲突,那么扩展方总是优先.如果想调用分派接收
者,那么可以使用限定符:

	class C {
	 fun D.foo() {
   	     toString()         // calls D.toString()
   	     this@C.toString()  // calls C.toString()
   	 }

扩展成员可以定义成open和override在子类中.这意味着扩展成员在分派接收者中是虚拟的,
在扩展接收者中是静态的.

### 6. Motivation
在Java中我们经常定义Utils类,FileUtils,StringUtils等等,特别是集合类.Collections

调用这些工具方法:

	// Java
	Collections.swap(list, Collections.binarySearch(list,
	Collections.max(otherList)), Collections.max(list));

每次调用都要输入类名,我们可以使用静态导入就可以这样:

	// Java
	swap(list, binarySearch(list, max(otherList)), max(list));

这稍微好了一点,但是我们不能从IDE中得到表达导入的任何帮助,而且不能:

	// Java
	list.swap(list.binarySearch(otherList.max()), list.max());

我们不可能实现所有会用到的方法在类中.但是扩展会帮助我们.
