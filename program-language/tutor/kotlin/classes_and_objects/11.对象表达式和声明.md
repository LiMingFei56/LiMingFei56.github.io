## 对象表达式和声明
有时候我们需要稍微修改一个类的实现,但是不想创建一个子类.java使用匿名内部类来实现
,kotlin使用对象表达式和对象声明来实现.


### 1. 对象表达式
使用"object"关键字来创建对象表达式,object后面可以跟多个超类型,使用","分隔.如果超
类型有构造函数,那么需要输入适当的参数.

也可以创建没有任何超类型的匿名对象:

	fun foo() {
	    val adHoc = object {
	        var x: Int = 0
	        var y: Int = 0
	    }
	    print(adHoc.x + adHoc.y)
	}

没有任何超类型的匿名对象,只能是本地和私有的声明.如果用于公有的函数返回和公有的属
性,那么该类型是Any的,不能访问匿名对象的成员.

	class C {
	    // Private function, so the return type is the anonymous object type
	    private fun foo() = object {
	        val x: String = "x"
	    }
	
	    // Public function, so the return type is Any
	    fun publicFoo() = object {
	        val x: String = "x"
	    }
	
	    fun bar() {
	        val x1 = foo().x        // Works
	        val x2 = publicFoo().x  // ERROR: Unresolved reference 'x'
	    }
	}

跟java一样,匿名内部类可以访问外部函数的变量,但是不同之外在于不用是final的.

### 2. 对象声明
单例模式是很常用的,对象声明可以简化单例模式.

	- 使用关键字代替class来定义类,就是对象声明.
	- 对象声明不是表达式,不能用于右操作.
	- 直接使用类名来引用对象.
	- 对象声明允许扩展别的类.
	- 对象声明不能是局部的(在函数中定义),但是可以嵌套在其他对象声明与非内部类中.

一个类中的对象声明可以标记为"companion".可以使用简单类名来访问对象声明中的成员.
	class MyClass {
	    companion object Factory {
	        fun create(): MyClass = MyClass()
	    }
	}

	val instance = MyClass.create()

可以省略"companion"对象声明的类名,使用Companion来代替.

	class MyClass {
	    companion object {
	    }
	}
	
	val x = MyClass.Companion

companion看起来像java的静态方法,但还是真实的成员对象.如可以实现接口.但是可以使用
@JvmStatic注释,使companion成为静态函数和字段.

### 3. 对象表达式和对象声明的语义差别

	- 对象表达式被调用时会立即执行
	- 对象声明是懒加载的,当第一次访问的时候加载
	- companion对象声明在主类被加载时初始化,语义同java静态初始化
