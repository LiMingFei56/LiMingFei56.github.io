## 代理属性
有一些使用属性的特殊要求,可以使用代理属性来实现:
	
	- 懒加载属性:只有在第一次访问的时候初始化.
	- 观察者属性:当该属性被修改时通知监听者.
	- 在Map中保存属性.

实现代理属性的语法:
	
	val/var <property name>: <Type> by <expression>

"by"关键字后面是代理,需要实现getValue和setValue2个函数.

当读取被代理的属性时,会调用代理方法getValue(thisRef,property),第一个参数是当前对
象this,第二个参数是这个属性.

当对被代理的属性赋值明,会调用代理方法setValue(thisRef,property,value),前面2个参
数同getValue,最后一个参数为赋值的值.

代理属性不一定是类的成员,它可以在函数和代码块中定义.

### 1. 标准代理属性

#### 1.1. Lazy
lazy()是一个接收lambde函数,返回一个Lazy<T>对象.当第一个访问该属性时会调用属性的
get()函数,get()函数会调用lazy的lambde并记住结果,之后就只会返回被记住的结果.

默认lazy是同步的,可以传递参数来改变这个情况:

	- LazyThreadSafetyMode.PUBLICATION	多个线程异步
	- LazyThreadSafetyMode.NONE			不处理同步异步关系

#### 1.2. Observable
Delegates.observable(),有两个参数,第一个参数是初始化的值,第二个参数是一个修改处
理程序.当属性分配新值之后会调用修改处理程序,处理程序有3个参数,第一个是该属性,第
二个是旧值,第三个是新值.

如果想拦截和否决属性分配,那么可以使用vetoable()代替observable(),修改处理在属性分
配前调用.

#### 1.3. 在Map中存储属性
常常会把数据保存到map中如,解析json或者动态处理等.这时可以使用map对象来作为属性的
代理.

	class User(val map: Map<String, Any?>) {
	    val name: String by map
	    val age: Int     by map
	}

### 2. 本地代理属性
可以在函数和代码块中使用代理属性,如懒加载:

	fun example(computeFoo: () -> Foo) {
	    val memoizedFoo by lazy(computeFoo)
	
	    if (someCondition && memoizedFoo.isValid()) {
	        memoizedFoo.doSomething()
	    }
	}

如果someCondition为false,那么memoizedFoo根本不会计算.

### 3. 代理属性规则
getValue()和setValue()函数作为代理类或扩展函数提供,如果代理类本身没有提供这2个函
数,那么可以使用扩展函数来实现.这2个函数需要使用关键字"operator"标记.

代理类可以实现ReadOnlyProperty and ReadWriteProperty接口来实现getValue和setValue
函数.

#### 3.1 只读属性(val)
代理类必须提供getValue()函数,并且有两个参数:
thisRef- 必须是属性的所有者或其超类型.
property- 必须是KProperty<*>或其超类型.

返回必须是跟属性相同的类型或其超类型.

#### 3.2 可变属性(var)
代理类不只提供上面的getValue()函数,还要提供setValue()函数,并且提供三个参数:
thisRef- 必须是属性的所有者或其超类型.
property- 必须是KProperty<*>或其超类型.
value- 必须是属性的同类型或超类型.

#### 3.3 翻译规则
编译器会对每个被代理的属性生成一个隐藏属性,隐藏属性的getter和setter是使用代理类
的getValue和setValue来实现,而被代理类是调用隐藏属性的getter和setter函数来实现.

	class C {
	    var prop: Type by MyDelegate()
	}
	
	// this code is generated by the compiler instead:
	class C {
	    private val prop$delegate = MyDelegate()
	    var prop: Type
	        get() = prop$delegate.getValue(this, this::prop)
	        set(value: Type) = prop$delegate.setValue(this, this::prop, value)
	}

编译器会传递代理需要的必要参数,this为当前对象.this::prop是对当前属性的反射,返回
KProperty对象.

### 4. 代理提供者
使用"operator fun provideDelegate()"函数可以扩展代理实现的逻辑,如果by右操作为
provideDelegate(),那么可以使用provideDelegate来创建代理类.

provideDelegate函数的参数同getValue.

	class ResourceDelegate<T> : ReadOnlyProperty<MyUI, T> {
	    override fun getValue(thisRef: MyUI, property: KProperty<*>): T { ... }
	}
	    
	class ResourceLoader<T>(id: ResourceID<T>) {
	    operator fun provideDelegate(
	            thisRef: MyUI,
	            prop: KProperty<*>
	    ): ReadOnlyProperty<MyUI, T> {
	        checkProperty(thisRef, prop.name)
	        // create delegate
	        return ResourceDelegate()
	    }
	
	    private fun checkProperty(thisRef: MyUI, name: String) { ... }
	}
	
	class MyUI {
	    fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }
	
	    val image by bindResource(ResourceID.image_id)
	    val text by bindResource(ResourceID.text_id)
	}

使用代理提供者和直接使用代理,编译器生成的代码不同:

	class C {
	    var prop: Type by MyDelegate()
	}
	
	// this code is generated by the compiler 
	// when the 'provideDelegate' function is available:
	class C {
	    // calling "provideDelegate" to create the additional "delegate" property
	    private val prop$delegate = MyDelegate().provideDelegate(this, this::prop)
	    val prop: Type
	        get() = prop$delegate.getValue(this, this::prop)
	}
