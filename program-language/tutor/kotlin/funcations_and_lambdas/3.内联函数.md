## 内联函数
调用函数都有运行时开销,每个函数都是一个对象,并且会捕获闭包.内存分配和虚拟调用都
引入了运行时开销.可以使用内联lambda函数来解决这个问题.

使用关键字"inline"来标记函数,可以使编译器不用为参数创建对象并生成调用.

内联函数最好不是复杂的功能,因为会使原函数扩大代码量.要是内联函数太大,不尽性能没
有提升,还会下降.

### 强制不内联
可以使用关键字"noinline"标记函数参数,那么lambda不会成为内联函数.

如果一个内联函数没有内联函数参数,也没有具体的类型参数,那么编译器会警告.使用
@Suppress("NOTHING_TO_INLINE")取消警告.

### 非本地返回
return可以使函数或匿名函数返回,但是lambda不能使封闭函数返回,内联lambda可以.
在内联lambda中使封闭函数返回,叫非本地返回.

	fun foo() {
		inlineFunction {
			return // OK: the lambda is inlined
		}
	}

	fun hasZeros(ints: List<Int>): Boolean {
		ints.forEach {
			if (it == 0) return true // returns from hasZeros
		}
		return false
	}


内联lambda不允许在另一个上下文中(另一个对象或一个嵌套函数).可以使用`crossinline `来标记.

### 参数化类型
有时我们需要访问传递给我们的类型作为参数:

	inline fun <reified T> TreeNode.findParentOfType(): T? {
		var p = parent
		while (p != null && p !is T) {
			p = p.parent
		}
		return p as T?
	}

### 内联属性
内联关键字"inline"可以标记属性的访问器getter和setter,也可以直接标记属性本身.

可以使用在没有backing field的属性中.

### 对公共API内联函数的限制

当内联函数是public或者是protected,而不是其他.那么该函数对于其他模块来说被认为是
公共API.在其他模块内调用这个函数,也有内联的效果.

如果调用模块在更改后没有重新编译,那么声明内联函数的模块的变化引起了二进制不兼容
的某些风险.

为了消除这个风险,公共API内联函数不允许使用非公共API的声明.
