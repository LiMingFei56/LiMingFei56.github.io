## 高阶函数与Lambdas

### 1. 高阶函数
高阶函数是把函数当参数和返回值的函数.

	fun <T> lock(lock: Lock, body: () -> T): T
	{
	    lock.lock()
	    try {
	        return body()
	    }
	    finally {
	        lock.unlock()
	    }
	}

body参数是一个函数类型,() -> T意思是没有参数,返回类型是T的函数.如果要调用lock需
要传一个函数的引用给lock.

	fun toBeSynchronized() = sharedResource.operation()

	val result = lock(lock, ::toBeSynchronized)

另一种更简单的方法是传递一个lambda表达式
	
	val result = lock(lock, { sharedResource.operation() })



### 2. Lambda表达式
Lambda表达式的简述

	- Lambda表达式总是被花括号括起来
	- 其参数(如果有)需要在->前面定义(参数类型可以省略)
	- 函数体在->之后定义.

在kotlin中有一个惯例,如果一个函数最后一个函数是函数类型,而且你要传递一个lambda表
达式,那么允许在圆括号外面定义.

	lock (lock) {
	    sharedResource.operation()
	}

如果lambda表达式是唯一的参数,那么()参数列表可以省略.

另一个约定,如果lambda表达式只一个参数,那么可以省略参数名和"->".使用默认的
参数名`it`.这个约定可以写LINQ-style代码:

	strings.filter { it.length == 5 }.sortedBy { it }.map { it.toUpperCase() }

如果lambda表达式参数不使用,那么可以使用"_"来代替参数名.

### 3. 解构的lambda

### 4. 内联函数


### 5. Lambda表达式和匿名函数
Lambda表达式和匿名函数是"函数文字",没有函数的声明,但是可以立即作为函数的参数.

	max(strings, { a, b -> a.length < b.length })

max是一个高阶函数,第二个参数是一个函数.传递一个Lambda表达式函数文字.等同与:

	fun compare(a: String, b: String): Boolean = a.length < b.length

### 5.1. 函数类型
要接收一个函数作为参数,那么需要指定一个函数类型,如上面max函数

	fun <T> max(collection: Collection<T>, less: (T, T) -> Boolean): T? {

(T,T) -> Boolean 就是定义的函数类型,接收2个通用类型参数,返回一个Boolean值
如果要记住每个参数的含义,可以使用命名参数.

	val compare: (x: T, y: T) -> Int = ...

如果要把函数类型使用到变量上,那么函数类型需要被"()"括起来,并且以"?"结尾:

	var sum: ((Int, Int) -> Int)? = null

### 5.2. Lambda表达式语法
	val sum = { x: Int, y: Int -> x + y }

	- 必须被花括号括起来
	- 参数定义及可选的参数类型声明
	- 函数体在->之后
	- 如果推断返回类型不是Unit,那么函数体内最后一个表达式的值作为返回值
	- 如果只有一个参数,那么可以省略参数名和->,使用it引用参数
	- 可以使用显式的return语句来返回,如果不使用显式,那么隐式是返回最后一个表达的
	  值
	- 如果函数最后一个参数是函数类型,那么可以在圆括号外定义

### 5.3. 匿名函数
使用lambda表达式一般不用指定返回类型,如果需要指定返回类型,可以使用匿名函数.

	fun(x: Int, y: Int): Int = x + y

匿名函数跟普通函数很像,只是没有函数名.参数和返回类型的定义方式与普通函数相同,只
是可以从上下文中推断参数和返回值的类型.

	ints.filter(fun(item) = item > 0)

匿名函数作为参数只能在圆括号中定义

匿名函数的return只返回本身,而lambda返回是使包含这个表达式的函数返回.

### 6 闭包(Closures)
lambda,匿名函数,本地函数,对象表达式可以访问闭包(内部代码块访问外部的变量),不像
Java,Kotlin允许修改闭包捕获的值:

	var sum = 0
	ints.filter { it > 0 }.forEach {
	    sum += it
	}
	print(sum)

### 7 函数文字与接收者
kotlin提供通过一个指定的接收者对象来调用函数文字的功能,在函数文字中,可以调用接收
者的任何函数,而不用任何限定符.类似扩展函数

	sum : Int.(other: Int) -> Int

	1.sum(2)

	val sum = fun Int.(other: Int): Int = this + other

可以用在变量类型:

	val represents: String.(Int) -> Boolean = { other -> toIntOrNull() == other}
	println("123".represents(123)) // true

可以用在函数参数:

	fun testOperation(op: (String, Int) -> Boolean, a: String, b: Int, c:
		Boolean) = assert(op(a, b) == c)
    
	testOperation(represents, "100", 100, true) // OK

当参数和返回值可以通过上下文推断出来,Lambda表达可以作为有接收者的函数文字.

	Type-safe Groovy-style builders.
