## Java调用Kotlin
Kotlin代码可以在JAVA中很方便的调用

### 1. 属性
Kotlin属性会按下面的规则来编译成JAVA元素:

	- 根据属性名来生成以get为前缀的getter函数
	- 如果是var属性,根据属性名来生成以set为前缀的setter函数
	- 私有属性,与属性名相同(只支持有backing fields的属性)
	- 如果属性名是以is开头,那么getter会生成is..()函数,如
	  open,getter->isOpen,setter->setOpen.作用于所有类型的属性,不只是Boolean

### 2. 包顶级
所有函数和属性定义在example.kt文件中,org.foo.bar包中.编译器会把这些函数和属性编
译到叫org.foo.bar.ExampleKtJAVA类中.

	// example.kt
	package demo
	
	class Foo
	
	fun bar() {
	}
	
	// Java
	new demo.Foo();
	demo.ExampleKt.bar();

可以使用`@JvmName`注解来指定生成的JAVA类:

	@file:JvmName("DemoUtils")

	package demo
	
	class Foo
	
	fun bar() {
	}
	
	/ Java
	new demo.Foo();
	demo.DemoUtils.bar();

具有相同的名称的JAVA类(相同的包名和文件名或@JVMNAME名称),会报错.可以使用注解使有
相同名称的JAVA类都定义到一个JAVA类中.

	@file:JvmName("Utils")
	@file:JvmMultifileClass

	// newutils.kt
	@file:JvmName("Utils")
	@file:JvmMultifileClass
	
	package demo
	
	fun bar() {
	}
	
	// Java
	demo.Utils.foo();
	demo.Utils.bar();

### 3. 字段实例
如果像一个Kotlin字段在JAVA中可见,那么可以使用@JvmField注解这个字段.这个字段不能
是open,override,const,delegated

lateinit 也可以是一个字段,该字段的可见性与setter可见性相同.

### 4. 静态字段
Kotlin属性定义在一个命名对象或者一个companion object对象里,有静态字段的意义.

通常上面的字段是私有的,可以通过下面的方法来显露:

	- @JvmField annotation,使属性据有其本身相同的可见性的静态字段
	- lateinit modifier,使属性所有其setter一样的可见性
	- const modifier,成静态字段

### 5. 静态函数
使用@JvmStatic标记的companion object函数就是静态函数.

可见性:
	- private被编到private中
	- private顶级声明被编到包本地声明
	- protect编译到protect中(JAVA允许同一个包中的其他类访问这个函数,但是kotlin不
	  会)
	- internal编译到public
	- public编译到public

### 6. KCLASS

	kotlin.jvm.JvmClassMappingKt.getKotlinClass(MainView.class)

### 7. 签名冲突
有时候需要对函数生成一个不一样的JVM签名,最常见的是类型擦除.使用@JvmName

### 8. 重载Generation
如果函数中使用的默认值,那么在JAVA中只显示全参数的函数,如果要暴露全部的重载函数,
那么使用注解@JvmOverloads.

可以使用在构造函数,静态函数.不能用在抽象函数.

主构造函数参数都有默认值,那么会生成一个使用默认值的无参构造函数.这个在上述中也有
效.

### 9. 捕获Kotlin异常
Kotlin中没有检查异常,所以Kotlin的JAVA声明不明声明异常的抛出.那么在JAVA中捕获
Kotlin异常,需要在kotlin中对抛出的异常函数添加@Throws(IOException::class)注解

### 10. 空安全
调用Kotlin函数可以返回null,所以可以正常的判断是否是空引用,或者捕获npe异常.

### 11. 泛型方差
Box<Super> as Box<? extends Super>
Box (or Foo<? super Bar> for contravariantly defined Foo)
只会在参数下转换成通配符,返回值中不会

@JvmWildcard  可以使不会生产通配符的参数生成
@JvmSuppressWildcards 使被注释的通用类型都不生成通配符

### 12. Notiong类型
JAVA类型没有一种可以表示Nothing,所以Nothing都会转换成原类型

List<Nothing>    ====> List emptyList()



