## 注解
注解是把元数据附加到代码上.要声明一个注解需要把`annotation`添加到类声明前面:

	annotation class Fancy

对注解添加附加数据,可以使用元注解:

	- @Target 指定使用注解的可能类型的元素.
	- @Retention 指定注解是否存储在编译的类文件中,以及它是否可以通过反射可见
	  (默认为true)
	- @Repeatable 允许在单个元素上多次使用相同的注解
	- @MustBeDocumented 指定注解是公共API的一部分,并应包含在生成的API文档中显示
	  的类或方法签名中.

### 使用
使用注解`@注解名`,添加到定义前面,可以注解类,函数,属性,表达式等.

### 注解构造函数
注解可以有带参数的构造函数:

	annotation class Special(val why: String)

	@Special("example") class Foo {}

允许的构造函数参数类型:

	- JAVA对应的原始类型
	- strings;
	- classes(Foo::class)
	- enums;
	- 其它注解
	- 上面列出的类型的数组

注解的参数不支持可空类型,因为JVM不支持注解把null作为值存储

如果一个注解被另一个注解作为参数,那么不用"@"操作符

如果需要使用class作为参数,那么使用KClass最好,编译器会自动转换成JAVA的class

### Lambdas
注解可以用于Lambdas表达式,编译器会把注解添加到生成invoke()函数上.

	annotation class Suspendable

	val f = @Suspendable { Fiber.sleep(10) }

### 注解使用目标
当对属性或主构造函数参数时,会生成多个JAVA元素,并在多个地方存储这个注解.如果要精
确指定,就要使用下面的语法:

	class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter

可以使用相同的语法来注解整个文件,将注解放到该文件的最上方,包声名的上面.

	@file:JvmName("Foo")

	package org.jetbrains.demo

如果有多个注解具有相同的目标,则可以使用简单的方法,定义目标,把多个注解放到方括号
中.

	class Example {
		@set:[Inject VisibleForTesting]
		var collaborator: Collaborator
	}

支持目标的完整列表:
	- file;
	- property (annotations with this target are not visible to Java);
	- field;
	- get (property getter);
	- set (property setter);
	- receiver (receiver parameter of an extension function or property);
	- param (constructor parameter);
	- setparam (property setter parameter);
	- delegate (the field storing the delegate instance for a delegated property).

要注解扩展函数的接收器参数使用下面语法:

	fun @receiver:Fancy String.myExtension() { }

如果没有指定目标,那么使用@Target定义的目标,如果有多个适用的目标,就按下列顺序选择
第一个目标:

	- param;
	- property;
	- field.

### JAVA注解
JAVA注解100%兼容Kotlin

JAVA注解的参数因为没有定义顺序,所以不能像一般参数那么传值,只能使用命名参数一来传
递.

	// Java
	public @interface AnnWithArrayMethod {
	    String[] names();
	}
	// Kotlin
	@AnnWithArrayMethod(names = arrayOf("abc", "foo", "bar")) class C

注解中的属性可以被访问:

	// Java
	public @interface Ann {
	    int value();
	}
	// Kotlin
	fun foo(ann: Ann) {
	    val i = ann.value
	}
