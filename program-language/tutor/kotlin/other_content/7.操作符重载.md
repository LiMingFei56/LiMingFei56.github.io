## 操作符重载
kotlin允许操作符重载,操作符有固定的语法和优先级.我们可以提供一个有固定函数名的成
员函数或扩展函数,而且该函数需要标记为"operator"

### 1. 1元操作符
* +a			a.unaryPlus()
* -a			a.unaryMinus()
* !a			a.not()

+a的处理方式:

	- 把a类型看成是T;
	- 在类型T中查找有"operator"修饰的unaryPlus()函数,可以是成员函数和扩展函数;
	- 如果没有找到就会报错;
	- 如果找到了并且这个函数返回类型R,那么+a表达式的类型就是R.

基本类型作了特定的优化,没有函数调用的消耗.

* a++			a.inc() + see below
* a--			a.dec() + see below

inc()和dec()函数必须返回一个值.而且不能突然返回一个不一样类型的值.

a++的处理方式:

	- 把a类型看成T;
	- 在类型T中查找有"operator"修饰的inc()函数;
	- 检查该函数的返回类型是不是T或者T的子类型.
计算表达式的效果:

	- 将a的值保存到临时变量a0中;
	- 将a.inc()的值分配给a;
	- 返回a0作为结果.

而++a就最后一步不一样:
	- 返回a作为结果.

### 2. 2元操作符
* a + b			a.plus(b)
* a - b			a.minus(b)
* a * b			a.times(b)
* a / b			a.div(b)
* a % b			a.rem(b), a.mod(b) (deprecated)
* a..b			a.rangeTo(b)

编译器只是把操作符翻译成后面的函数调用,取模操作1.1前使用mod函数,1.1后使用rem操作

#### in操作符
* a in b		b.contains(a)
* a !in b		!b.contains(a)

过程是相同的,但是参数是相反的.

#### 索引访问操作符
* a[i]					a.get(i)
* a[i, j]				a.get(i, j)
* a[i_1, ..., i_n]		a.get(i_1, ..., i_n)
* a[i] = b				a.set(i, b)
* a[i, j] = b			a.set(i, j, b)
* a[i_1, ..., i_n] = b	a.set(i_1, ..., i_n, b)

方括号被转换成适当数量参数的get和set函数.

#### 执行操作符
* a()					a.invoke()
* a(i)				a.invoke(i)
* a(i, j)				a.invoke(i, j)
* a(i_1, ..., i_n)	a.invoke(i_1, ..., i_n)

括号被转换成适当数量参数的invoke函数.

#### 赋值增强操作符
* a += b		a.plusAssign(b)
* a -= b		a.minusAssign(b)
* a *= b		a.timesAssign(b)
* a /= b		a.divAssign(b)
* a %= b		a.remAssign(b), a.modAssign(b) (deprecated)

a += b的处理方法:

	- 如果右则函数可用
		- 判断相应的算术运算是否存在如(plus()和plusAssign),会报错(二义性).
		- 确保返回类型是Unit,否则报错.
		- 生成代码a.plusAssign(b)
	- 否则尝试生成代码a = a + b(其中包括类型检查,确保a + b 是a类型或其子类型).

注意,赋值操作不是表达,没有返回值.

#### 相等与不相等操作符
* a == b		a?.equals(b) ?: (b === null)
* a != b		!(a?.equals(b) ?: (b === null))

注意:===和!==是不可重载的,因为没有本应的约定.

null == null永远是true,非空值 == null永远是false,而且不会调用equals().

#### 逻辑操作符
* a > b			a.compareTo(b) > 0
* a < b			a.compareTo(b) < 0
* a >= b		a.compareTo(b) >= 0
* a <= b		a.compareTo(b) <= 0

返回都转换成compareTo()函数

#### 属性委托操作符

#### 中缀调用命名函数
