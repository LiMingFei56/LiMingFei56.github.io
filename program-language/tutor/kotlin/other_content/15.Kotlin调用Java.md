## Kotlin调用Java代码
Kotlin的设计思想是能用Java的就用Java的不能用才自己实现,主要的目标是兼容Java和使
开发语言表达更高效自然(语法糖).

Kotlin中可以很方便的调用Java代码,Java中也一样.差不多100%兼容

### 1. Getter和Setter
遵循Java对象的约定(字段通用get和set方法访问),在Kotlin使用属性来访问.

	如:User.getName()   -> User.name

### 2. 返回void
Java函数如果返回void类型,那么在kotlin中会返回Unit类型.

### 3. 转换有效标识符
Kotlin中有些关键字在Java中是有效标识符,可以使用"``"来转换Java中标识符

### 4. 空安全与平台类型
Java中任何引用都可以为空,这对Kotlin中的空安全结构是无意义的.所以编译会把Java中的
引用编译成平台类型,Kotlin对平台类型的空检查是放宽的.

如果为空,会抛出空指针异常.

如果把null值传给,Kotlin非空的类型,那么也会报错.

### 5. 平台类型符号
在Kotlin中不能显式的使用平台类型,但是可以有助记符:

	- T! means "T or T?",
	- (Mutable)Collection<T>! means "Java collection of T may be mutable or not,
	  may be nullable or not",
	- Array<(out) T>! means "Java array of T (or a subtype of T), nullable or
	  not"

### 6. 可空性注解
具有可空性注解(@Nullable和@NotNull)的Java类型不会编译成平台类型,会编译成Kotlin中
对应的可空和非空类型

编译器支持的可空性注解:

	- JetBrains (@Nullable and @NotNull from the org.jetbrains.annotations
		package)
	- Android (com.android.annotations and android.support.annotations)
	- JSR-305 (javax.annotation)
	- FindBugs (edu.umd.cs.findbugs.annotations)
	- Eclipse (org.eclipse.jdt.annotation)
	- Lombok (lombok.NonNull).

### 7. JSR-305 支持
@Nonnull定义类型的可空性, @Nonnull(when = ...)
When.ALWAYS 为非空
When.MAYBE和When.NEVER 为可空
WHen.UNKNOWN 为平台类型

类型限定别名(Type qualifier nicknames (since 1.1.50))
如果一个注释定义了`@TypeQualifierNickname`和JSR-305 `@Nonnull`(或
`@CheckForNull`),那么注解类型本身用于检查精确的可空性,并且具有与该可空性注解相同
的含义.

	@TypeQualifierNickname
	@Nonnull(when = When.ALWAYS)
	@Retention(RetentionPolicy.RUNTIME)
	public @interface MyNonnull {
	}
	
	@TypeQualifierNickname
	@CheckForNull // a nickname to another type qualifier nickname
	@Retention(RetentionPolicy.RUNTIME)
	public @interface MyNullable {
	}
	
	interface A {
	    @MyNullable String foo(@MyNonnull String x); // seen as `fun foo(x: String):
	String?`
	    String bar(List<@MyNonnull String> x);       // seen as `fun bar(x:
	List<String>!): String!`
	}

Type qualifier defaults (since 1.1.50)
`@TypeQualifierDefault`允许对作用域定义可空性.
	
	- ElementType.METHOD 返回类型的函数
	- ElementType.PARAMETER 参数值
	- ElementType.FIELD 字段

	@Nonnull
	@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
	public @interface NonNullApi {
	}
	
	@Nonnull(when = When.MAYBE)
	@TypeQualifierDefault({ElementType.METHOD, ElementType.PARAMETER})
	public @interface NullableApi {
	}
	
	@NullableApi
	interface A {
	    String foo(String x); // fun foo(x: String?): String?
	 
	    @NotNullApi // overriding default from the interface
	    String bar(String x, @Nullable String y); // fun bar(x: String, y: String?):
	String 
	    
	    // The type of `x` parameter remains platform because there's explicit
	    // UNKNOWN-marked
	    // nullability annotation:
	    String qux(@Nonnull(when = When.UNKNOWN) String x); // fun baz(x: String!):
	String?
	}

编译配置
JSR-305 可以使用-Xjsr305标签来配置:

	- -Xjsr305=strict 使JSR-305作为任何明文的可空性注解工作,并且检查注解使用的规
	  范性
	- -Xjsr305=warn 使不合适的使用只显示警告而不是错误
	- -Xjsr305=ignore 使编译器忽略JSR-305注解

### 8. 类型映射
Kotlin处理一些JAVA的类型,这些类型不是支持使用JAVA的类型,而是把JAVA的类型映射成
Kotlin类型.映射只有在编译中运行,运行时保持类型不变.

Java type	Kotlin type
byte	kotlin.Byte
short	kotlin.Short
int	kotlin.Int
long	kotlin.Long
char	kotlin.Char
float	kotlin.Float
double	kotlin.Double
boolean	kotlin.Boolean

java.lang.Object	kotlin.Any!
java.lang.Cloneable	kotlin.Cloneable!
java.lang.Comparable	kotlin.Comparable!
java.lang.Enum	kotlin.Enum!
java.lang.Annotation	kotlin.Annotation!
java.lang.Deprecated	kotlin.Deprecated!
java.lang.CharSequence	kotlin.CharSequence!
java.lang.String	kotlin.String!
java.lang.Number	kotlin.Number!
java.lang.Throwable	kotlin.Throwable!

java.lang.Byte	kotlin.Byte?
java.lang.Short	kotlin.Short?
java.lang.Integer	kotlin.Int?
java.lang.Long	kotlin.Long?
java.lang.Character	kotlin.Char?
java.lang.Float	kotlin.Float?
java.lang.Double	kotlin.Double?
java.lang.Boolean	kotlin.Boolean?

Java type	Kotlin read-only type	Kotlin mutable type	Loaded platform type
Iterator<T>	Iterator<T>	MutableIterator<T>	(Mutable)Iterator<T>!
Iterable<T>	Iterable<T>	MutableIterable<T>	(Mutable)Iterable<T>!
Collection<T>	Collection<T>	MutableCollection<T>	(Mutable)Collection<T>!
Set<T>	Set<T>	MutableSet<T>	(Mutable)Set<T>!
List<T>	List<T>	MutableList<T>	(Mutable)List<T>!
ListIterator<T>	ListIterator<T>	MutableListIterator<T>
(Mutable)ListIterator<T>!
Map<K, V>	Map<K, V>	MutableMap<K, V>	(Mutable)Map<K, V>!
Map.Entry<K, V>	Map.Entry<K, V>	MutableMap.MutableEntry<K,V>
(Mutable)Map.(Mutable)Entry<K, V>!

int[]	kotlin.IntArray!
String[]	kotlin.Array<(out) String>!

### 9. JAVA泛型
Kotlin中的泛型与JAVA中的有点不同,在使用时会有一些转换

### 9.1 通配符转换成类型预测
	- Foo<? extends Bar> becomes Foo<out Bar!>!,
	- Foo<? super Bar> becomes Foo<in Bar!>!;

### 9.2 Java原始类型转换成*号类型
	- List becomes List<*>!, i.e. List<out Any?>!.

像JAVA一样,Kotlin在运行时不保留类型参数的具体类型.所以只允许*号类型的检查

	if (a is List<Int>) // Error: cannot check if it is really a List of Ints
		// but
	if (a is List<*>) // OK: no guarantees about the contents of the list

### 10. JAVA数组
Kotlin中数组是不变的,不像JAVA.JAVA中允许Array<String>赋值给Array<Any>,Kotlin中不
允许.JAVA中数组会被映射成,Array<(out) String>!)平台类型.

Kotlin编译器会对数组进行优化调整.使之与JAVA中兼容.

### 11. JAVA扩展参数
调用有扩展参数的JAVA函数时,Kotlin传递数组时需要加上"*"操作符

### 12. 操作符
由于java无法标记的方法，所以要用运算符语法，Kotlin允许使用正确的名称和签名的任何
java方法运算符重载等公约（invoke()等）调用java方法采用中缀调用语法是不允许的。

### 13. 检查型异常
在Kotlin中,所有异常都是非检查型的.Kotlin调用有检查型异常的JAVA函数时,不会有任何
提示.

### 14. Object函数
Java中类型导入Kotlin时,所有Object类型引用会被转换成Any.因为Any不是平台指定,所以
只实现了toString,hashCode,equals函数.如果要调用其他Object函数,需要使用扩展函数.

wait()/notify()

	(foo as java.lang.Object).wait()

getClass()

	val fooClass = foo::class.java
	val fooClass = foo.javaClass

clone(),重写clone函数

	class Example : Cloneable {
		override fun clone(): Any { ... }
	}

finalize()

	class C {
		protected fun finalize() {
			// finalization logic
		}
	}

### 15. 继承JAVA类
一个类和任何多的接口作为kotlin的超类.

### 16. 访问JAVA静态函数
跟访问Companion Ojbect 一样的访问

###	17. JAVA类反射
instance::class.java, ClassName::class.java or instance.javaClass

### 18. SAM 转换
simgle abstract method
跟JAVA 8一样,Kotlin支持SAM 转换

### 19. 使用JNI
使用external fun foo(x: Int): Double 来静态声明一个调用本地函数的函数.

其他的跟JAVA中一样
