## 解构声明
解构就是创建多个变量来保存对象的属性.

编译器会按照对象属性的定义顺序来生成compaonentN()函数.如Parson有name和age2个属性
.我们可以

	val (name, age) = person

编译器会处理成:

	val name = person.component1()
	val age = person.component2()

解构可以用到任何右操作表达个,只要提供对应的compaonentN()函数.


### for-loop 

	for ((a, b) in collection) { ... }

### 函数返回2个变量

	data class Result(val result: Int, val status: Status)
	fun function(...): Result {
	    // computations
	    
	    return Result(result, status)
	}
	
	// Now, to use this function:
	val (result, status) = function(...)

	* Pair<Int, Status>

### 使用Maps
确保解构可以使用,要保住2个规则:
	- 提供iterator()函数
	- 提供compaonentN()函数

	for ((key, value) in map) {
	   // do something with the key and the value
	}

	operator fun <K, V> Map<K, V>.iterator(): Iterator<Map.Entry<K, V>> =
	entrySet().iterator()
	operator fun <K, V> Map.Entry<K, V>.component1() = getKey()
	operator fun <K, V> Map.Entry<K, V>.component2() = getValue()

### 忽略某个属性
可以使用"_"来忽略某个不使用的属性.

	val (_, status) = getResult()
	对应的conpaonent1()函数不会被调用

### 解构和lambda使用
如果lambda的参数有提供compaonentN()函数的对象,那么可以结合解构来使用

	map.mapValues { entry -> "${entry.value}!" }
	map.mapValues { (key, value) -> "$value!" }
	
	{ a -> ... } // one parameter
	{ a, b -> ... } // two parameters
	{ (a, b) -> ... } // a destructured pair
	{ (a, b), c -> ... } // a destructured pair and another parameter
	
	map.mapValues { (_, value) -> "$value!" }
	
	map.mapValues { (_, value): Map.Entry<Int, String> -> "$value!" }
	
	map.mapValues { (_, value: String) -> "$value!" }
