## 范围
范围表达式是使用rangeTo()函数,".."操作符,使用关键字"in"和"!in"来判断是否在范围里
.范围可以定义任何可以比较的类型中,但是对整型会有优化.

	if (i in 1..10) { // equivalent of 1 <= i && i <= 10
	    println(i)
	}

整型(IntRange, LongRange, CharRange),有个额外的特性,可以被迭代,编译器负责将这类
型于Java的索引循环,没有额外的开销.

	for (i in 1..4) print(i) // prints "1234"

	for (i in 4..1) print(i) // prints nothing

	for (i in 4 downTo 1) print(i) // prints "4321"   反顺序迭代

	for (i in 1..4 step 2) print(i) // prints "13"    设置步数

	for (i in 4 downTo 1 step 2) print(i) // prints "42"

	for (i in 1 until 10) { // i in [1, 10), 10 is excluded  不包含结束值
		println(i)
	}

### 范围的工作原理
范围会实现一个`ClosedRange<T>`接口,该接口是一个闭区间的数学定义,具有可比性的类型
定义.它有两个端点:start和endInclusive.主要操作是包含,使用"in"和"!in"

有一个Progressions(IntProgression, LongProgression, CharProgression),表示范围的
进程.定义第一个元素,最后一个元素和一个非零的步数.第一个元素是第一个,后面的元素是
前面一个元素加上一个步数得到的,直到最后一个元素.最后一人元素总是会被迭代的,除非
是空范围.

Progressions是`Iterable<N>`的子类型.当N是整型时,编译器会把范围优化成
JAVA/Javascript的下标迭代.

".."操作符会创建一个实现`ClosedRange<T>`接口,继承*Progression的对象.downTo()和
step()函数属于*Progression.Progressions有个`fromClosedRange`的构造函数.

	IntProgression.fromClosedRange(start, end, step)

最后一个元素是计算出的最大值,但是不能比end+step大,不能比end-step小.如:(last -
first) % step == 0

### 工具函数

#### rangeTo()
	class Int {
	    //...
	    operator fun rangeTo(other: Long): LongRange = LongRange(this, other)
	    //...
	    operator fun rangeTo(other: Int): IntRange = IntRange(this, other)
	    //...
	}

浮点数没有定义rangTo函数,可以使用

	public operator fun <T: Comparable<T>> T.rangeTo(that: T): ClosedRange<T>

来代替,返回的范围不能用来迭代.

#### downTo()
任何整型都有downTo()的扩展函数:

	fun Long.downTo(other: Int): LongProgression {
	    return LongProgression.fromClosedRange(this, other.toLong(), -1L)
	}
	
	fun Byte.downTo(other: Int): IntProgression {
	    return IntProgression.fromClosedRange(this.toInt(), other, -1)
	}

#### reversed()
每个*Progression都扩展了reversed(),都返回逆转Progression

	fun IntProgression.reversed(): IntProgression {
		return IntProgression.fromClosedRange(last, first, -step)
	}

#### step()
step()也是*Progression的扩展

	fun IntProgression.step(step: Int): IntProgression {
	    if (step <= 0) throw IllegalArgumentException("Step must be positive, was:
	$step")
	    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step
	else -step)
	}
	
	fun CharProgression.step(step: Int): CharProgression {
	    if (step <= 0) throw IllegalArgumentException("Step must be positive, was:
	$step")
	    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step
	else -step)
	}
	
	(1..12 step 2).last == 11  // progression with values [1, 3, 5, 7, 9, 11]
	(1..12 step 3).last == 10  // progression with values [1, 4, 7, 10]
	(1..12 step 4).last == 9   // progression with values [1, 5, 9]
