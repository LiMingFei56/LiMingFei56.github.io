## 1. 数据类型
### 1.1. Swift是强类型，静态语言
> 1. 变量声明时需要决定变量类型，可以使用类型推导或显式定义变量类型
> 2. 变量不会隐式的类型转换，需要强制转换,如Double(1)
> 3. 变量支持可选类型，代表空值(nil)

### 1.2. 声明变量
> 1. 使用关键字“let”定义常量，使用前必须初始化，初始化后不能修改
> 2. 使用关键字“var”定义变量，使用前必须初始化，初始化后可以修改值
> 3. 常量和变量声明时必须指定类型（如果声明时指定初始化的值，可以使用类型推导）
> 4. 可以在一行中声明多个常量或变量，使用“,”分隔，在声明最后可以设置这几个类型
> 5. 常量和变量的名称可以是unicode值，但不能有空格、箭头、无效unicode代码、线条
>    和图形，也不能以数字开头。
> 6. 声明后常量和变量的名称不能重复声明，不能改变类型，不能把常量改成变量，不能
>    把变量改成常量。
> 7. 如果必须使用关键字作为变量名称，使用“`”来定义（不推荐）

### 1.3. 打印常量和变量
> 使用print函数
> print("The current value of friendlyWelcome is \(friendlyWelcome)")

### 1.4. 注释
> 1. 单行注释：使用"//"
> 2. 多行注释：使用"/*"和"*/"多行注释，可以嵌套

### 1.5. 分号
> Swift可以不用分号来表示一个语句的结束，如果一行有多条语句可以使用分号

### 1.6. 整型
> 1. 默认使用Int来定义整型，大小是计算机字的大小
> 2. Swift还提供有符号和无符号指定大小的整型，Int8、Int16、Int32、Int64，还有无
>    符号UInt8、UInt16、UInt32、UInt64
> 3. 取整型数值大小UInt8.min,UInt8.max

### 1.7. 浮点数
> 1. Double 64位
> 2. Float  32位

### 1.8. 类型安全和类型推断
> Swift是类型安全的，不能把String传递给Int变量，代码编译时会检查并报告出这些错误
> 。这也不意为着声明变量时需要手动指定数据类型，当变量声明时并初始化，Swift会使
> 用类型推断来根据初始化值的类型，指定变量的类型。
>
> 整型总是被推断成Int，浮点型总是被推断成Double

### 1.9. 字面值
#### 1.9.1. 整型
> 1. 10进制，没有前缀
> 2. 2进制，0b前缀
> 3. 8进制, 0o前缀
> 4. 16进制，0x前缀

#### 1.9.2. 浮点型
> 1. 10进制，没有前缀 1.25e2 = 1.25 x 10^2
> 2. 16进制，0x前缀   0xFp2 = 15 * 2^2

注：数字为了可读性可以使用多于的"0"和"_"来分隔数字，如let paddedDouble =
000123.456，let oneMillion = 1_000_000

### 1.10. 类型转换
#### 1.10.1 整型转换
> 一般使用通用整型Int，除非必要情况可以使用其他整型类型。因为整型类型取值范围都
> 不同，所以要根据实际情况选择整型类型来显示转换同一类型。
> SomeType(ofInitialValue)是Swift默认类型转换的方法，如UInt16(UInt8)就是UInt16有
> 个接收UInt8的构造器，可以使用扩展方法来自定义转换。

#### 1.10.2 整型和浮点型转换
> 整型转浮点型如Double(3)，是创建一个新的Double的值。浮点转整型，总是截断小数部
> 分

### 1.11. 别名
> 根据上下文对一个类型起一个更适合的名字，可以用别名，使用关键字"typealias"来定
> 义。定义后可以使用别名来代表该类型。如typealias AudioSample = UInt16

### 1.12. 布尔值
> Swift支持布尔值Bool，只有2个值true和flase。不像C语言，1不等于true，1和true不能
> 相互转换。

### 1.13. 元组
> 1. 元组把多个类型的值组合成一个复合值，其中的元素类型不必一样。使用"()"来表示。
> 2. 元组可以分解成单个常量或变量，如let (statusCode, statusMessage) = 
>    http404Error
> 3. 如果只需要某些值，可以使用"_"来忽略其他的元素。
> 4. 可以使用下标来访问元素，如http404Error.0。
> 5. 定义元组时可以对元素设置名字，如let http200Status = (statusCode: 200,
>    description: "OK")
> 6. 元组作为返回值很有用，但是不能用于复杂的类型结构

### 1.14. 可选项Optionals
> 用来表示一个可能不存在的值，有两种情况：一是有个值，打开Optionals访问值;二是没
> 有值，一般用nil表示。
>
> 表示一个可选项Optional Int = Int?，问号表示这可能是一个Int值，也有可以没有值。
>
> 可以在if表达式里使用Optional和nil来进行比较，"=="等于，"!="不等于
> 如果确定Optional里有值，可以在值的后面用"!"，来取值
>
> Optional Binding在if和while表达式判断Optional有无值，有值就会把值赋给一个新的
> 常量或变量。if let constantName = someOptional
> 可以在if表达中包括多条Bool表达式和Optional Binding表达式，用","分隔。
> 在If表达式中创建的变量只在表达式中可用。
>
> 隐式解包，当Optinal始终会有一个值时，每次使用都要加上"!"，这时可以使用隐式解包
> ，把"?"替换为"!"，这时使用时不用加上"!"。

### 1.15. 错误处理
> 1. 抛出一个错误func canThrowAnError() throws {
> 2. 使用do{try}catch{}来捕获异常，catch可以有多个子句

### 1.16. 断言与前提条件
> 一般用于测试，表达式为true时程序继续执行，当为false时程序终止并退出。与异常不
> 一样，断言不能捕获。
> 
> assert: 检查自己代码内部的错误
> precondition: 检查传入参数是否正确
>
> 使用 assert(_:_:file:line:)来声明一个断言
> 使用 assertionFailure(_:file:line:)来声明一个失败的断言
>
> 使用 precondition(_:_:file:line:)来声明一个前提条件
> 使用 preconditionFailure(_:file:line:)来声明一个失败的前提条件
>
> 编译时使用-Ounchecked来取消precondition的检查，会假设前提条件为真，并优化代码
> ， fatalError(_:file:line:)方法总是终止程序，不管优化如何。可以使用该方法来标
> 注未完成的方法。
>
> 注：-Onone -O -Ounchecked 
