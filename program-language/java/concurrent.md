---
layout: page
permalink: /program-language/java/concurrent
---

Concurrent

## 原子操作
> 在并发编程中，一个操作（或一组操作）是原子的、连续的、不间断并且不能被打断的。原子
  操作在多线程中保证数据的一致性和可见性。

## 为什么需要原子操作？
> 编译器和处理器为了提高程序的性能，会对无数据依赖的代码和指令进行重排序。在个线程中
  重排序没有影响，但是在多线程并发时会出现不可预计的结果。

> CPU为了并发执行线程，会在线程间快速切换，一个线程读及修改但没有写时，CPU切换到另一个
  线程读及修改和写。最后切回来时，第一个线程再写就是不对的。

> CPU根据平台问题对内存的写有时会分为多次，当进行一次后，数据总线被另一个线程获得来读，
  这个数据，那么读到的是不完整的数据。

## 实现原子操作
> 在指令前加lock指令，会使当前的指令对总线加锁，别的程序不能通过总线访问内存。

###原子操作的算法
* Lock
* Lock-Free CAS
* Wait-Free
* Wait-Free-Population-Oblivious

## Synchronized关键字
### Synchronized介绍
> Java关键字Synchronized锁定一个对象、方法、类来使多线程访问同步，一次只有一个线程
  可以获得锁，其他的线程需要等待，当锁释放时再竞争锁。

### Synchronized原理
> synchronized关键字编译后会在同步块的前后添加上montorenter和monitorexit两个字节码
  指令，这两个字节码指令都需要一个指向锁定和解锁对象的reference,如果指定了同步的对象
  reference就指向这个对象，如果修饰的是方法，如果是类方法就指向Class对象，如果是实例
  方法就指向这个实例。

### Synchronized类别
> Synchronized可以理解为内存锁，锁定一段内存后，其他的线程不能访问。

* 对象锁：锁定一个对象，访问这个对象时需要等待。
* 方法锁：普通方法也是锁定当前对象；静态方法是锁定类Class对象。
* 类锁：锁定静态方法时，就是锁定类，同步类下的所有静态方法。

### Synchronized缺点
1. 多线程竞争的情况下，频繁的加锁解锁导致过多的线程上下文切换，由于java线程是基于操作
   系统内核线程实现的，所以如果阻塞或者唤醒线程都需要切换到内核态操作，这需要耗费
   许多CPU时钟。
2. 一个线程持有锁，会导致其他请求该锁的线程挂起。
3. 如果高优先级线程请求的锁，被低优先级线程占用，则会发生优先级倒置。

### 锁优化
#### 锁自旋
> 一个时间只有一个线程获取锁，其他线程需要挂起，处理器挂起需要大量资源。所以有线程自旋，
  如插入几条循环来等待获取锁。对频繁的锁切换有很大的优化。就是自旋时间不好控制。

#### 锁消除
> 代码上要求同步，但是虚拟机检测到不存在共享数据竞争的情况下，会做锁消除。

#### 锁粗化
> 一般情况下锁应该范围尽可能的小。但是如果是循环内的锁，才可以通过锁粗化来避免频繁的
  加锁解锁消耗性能。

#### 偏向锁
> Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”概念，
  Java SE1.6一共有4种状态，无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们
  会随着竞争情况不断升级，锁可以升级但是不能降级。

> 锁对象第一次被线程获取的时候，虚拟机把对象头的标识位设置为"01"，可偏向模式，如果通
  过CAS操作把mark word设置为当前线程的ID，如果CAS操作成功，这样以后这个线程每次进入
  这个锁的同步块时，虚拟机不再进行任何操作。

> 一旦有其他线程竞争这个锁，则偏向模式宣布结束。

#### 轻量级锁
> 代码进入同步块时，如果对象没有被锁定，虚拟机首先在当前线程的栈帧建立一个名为
  lock record的记录，存储锁对象目前的mark word，官方称之为displaced mark word。
  然后虚拟机通过CAS操作将对象头的mark word更新为指向lock record，如果成功则该线程或
  得了锁，如果失败，则膨胀为重量级锁。

## java.util.concurrent.atomic
> 原子操作数据，是用volatile实现的。

## java.util.concurrent.locks
### ReentrantLock
> ReentrantLock实现Lock接口，是一个循环非阻塞的锁，可以实现Synchronized的功能，并且
  比它的功能更强大。原理是使用volatile变量实现的。

### ReentrantLock分类
#### 公平锁
> 公平锁是用先进先出(FIFO)的算法实现的，顺序获取锁。

#### 非公平锁
> 非公平锁是自定义优先策略来实现的。

