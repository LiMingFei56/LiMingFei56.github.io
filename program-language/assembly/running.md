---
layout: page
permalink: /program-language/assembly/running
---

## 运行原理

每种结构的CPU指今集不同
每种结构的CPU寄存器数量不同
每种结构的CPU总线大小不同

### CPU指令长度
CPU中指令的长度不一样，是可变长度的指令。8086中指令长度从1〜6,最长为6.指令是按字节
来取的，一条指令有几个字节就取几次。

8086内部的BIU部件里有个指令队列（6个字节），是用来暂时存放从内存取出来的指令，CPU要
执行指令时再从指令队列中取出全部的机器码。

指令前几位是操作码，操作码决定了指令长度等信息。

### CPU对存储器的读写
CPU通过总线来与存储器交互，总线分为控制总线、地址总线、数据总线

控制总线 - 有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制
数据总线 - 总线根数决定一次传输数据的大小，一次传输数据的大小叫字
地址总线 - 总线根数决定支持内存的大小，一个CPU有N根地址线，叫作总线宽度为N，最多可以
    寻找2的N次方个内存单元

CPU会把不同物理硬件的内存与随机内存看成一个逻辑存储器，都与CPU总线相连，往显卡内存地址
写入数据，相当与跟显卡通信，显示数据到显示器。

### 读取指今
CPU通过CS和IP来取指令，读取一条指令后，IP中地址自动增加，指向下一条指令。

### 指令转移
* 无条件转移指令, jmp
* 条件转移指令，jcxz
* 循环指令， loop
* 过程
* 中断

使用jcxz实现if
使用call和ret实现函数调用

#### jmp
jmp指令要给出两种信息：
1. 转移的目的地址
2. 转移的距离(段间转移、段内短转移、段内近转移)

jmp cs:ip
jmp shor 标号 - 转到标号处执行指令
jmp far ptr 标号 - 实现的是段间转移，又称远转移
jmp word ptr 内存单元地址 - 段内转移
jmp dword ptr 内存单元地址 - 段间转移


jcxz 标号 - 条件转移指令，所有的有条件转移指令都是短转移。

ret - 使用栈中的数据，修改IP的内容，从而实现近转移
retf - 使用栈中的数据，修改CS和IP的内容，从而实现远转移

call - 将当前IP或CS和IP压入栈中，然后转移

### 栈机制
CPU使用PUSH和POP操作来实现栈的插入和删除，SS:SP就是指向栈顶的地址。栈是向低位地址
延伸。

### 源程序
汇编源程序包含两种指令，伪指令和汇编指令。
程序是由一些段组成的，代码段，数据段，栈段，使用这些可以组成小程序

#### 伪指令
编译器来执行的指令，编译器根据伪指令来进行相关的编译工作。

段定义 - 用来定义一个段

    段名 segemnt
    段名 ends

汇编结束标记

    end

假设 - `assume`， 把CPU中某个段寄存器与程序中定义的段相关联

标号- 相当于标识符，一个标号指代一个地址

offset - 取标号偏移地址

#### 程序返回
使用中断 

    int 21H

#### 数据

dw - 定义字型数据
dd - 双字型数据
db - 定义字符类型数据  '...'
H - 十六进制
B - 二进制

body - 字节，数据长度
word - 字，数据长度

### 中断过程

1. （从中断信息）取得中断类型码
2. 标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中）
3. 设置标志寄存器的第8位TF和第9位IF的值为0
4. CS的内容入栈
5. IP的内容入栈
6. 从内存地址为中断类型码*4 和中断类型码*4 + 2 的两中字单元中读取中断处理程序的入口地址
    设置IP和CS

处理程序：
1. 保存用到的寄存器
2. 处理中断
3. 恢复用到的寄存器
4. 用iret指令返回

处理程序需要实现的功能：
1. 把处理程序放到内存中, 使用movsb指令，把代码段送入内存
2. 设置中断向量表，使用mov设置内存中的向量表

### 端口
各种硬件的芯片都和CPU的总线相连，芯片内部都有寄存器，CPU可以通过控制总线向这些寄存器
所在的芯片发送端口读写

#### 端口读写
in - 读取内容
out - 写入内容
