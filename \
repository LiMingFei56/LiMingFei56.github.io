---
layout: post
title: Kotlin Class
categories: lang
tags: [lang]
date: 2022-09-22
---

## Kotlin Class

> class Person { /*...*/ }
> class Empty

### Constructors

    // primary constructor, only one 
    class Person constructor(firstName: String) { /*...*/ }

> 如果主构造函数没有什么注解和可见性修饰, 那么`constructor`可以忽略
> 主构造函数没有代码块, 可以写在`init`块中, `init`块可以有多个, 与在代码中的顺序一致, 与属性定义交错在一起
> 主构造函数定义的参数可以当属性使用, 可以有默认值

    class Person(val pets: MutableList<Pet> = mutableListOf())

    class Pet {
        constructor(owner: Person) {
            owner.pets.add(this) // adds this pet to the list of its owner's pets
        }
    }

> 定义Secondary constructors
> Secondary constructors, 如果主构造函数不为空, 那么最终需要调用主构造函数

    class Person(val name: String) {
        val children: MutableList<Person> = mutableListOf()
        constructor(name: String, parent: Person) : this(name) {
            parent.children.add(this)
        }
    }

> `init`块会在第二构造函数前调用
> 如果非抽象类没有定义构造函数, 那么会创建默认的公共的无参的主构造函数

>   On the JVM, if all of the primary constructor parameters have default values, the compiler will generate an additional parameterless constructor which will use the default values. This makes it easier to use Kotlin with libraries such as Jackson or JPA that create class instances through parameterless constructors

### Creating instances of classes

    // Kotlin does not have a new keyword.
    val invoice = Invoice()

### Class members

Classes can contain:

    Constructors and initializer blocks
    Functions
    Properties
    Nested and inner classes
    Object declarations
    
### Abstract classes

    使用`abstract`修饰类和方法

    abstract class Polygon {
        abstract fun draw()
    }

    class Rectangle : Polygon() {
        override fun draw() {
            // draw the rectangle
        }
    }

    抽象类可以使用`open`覆盖一个非抽象类

    open class Polygon {
        open fun draw() {
            // some default polygon drawing method
        }
    }

    abstract class WildShape : Polygon() {
        // Classes that inherit WildShape need to provide their own
        // draw method instead of using the default on Polygon
        abstract override fun draw()
    }

## Inheritance

> `Any`是默认超类, 有三个方法`equals()`, `hashCode()`, `toString()`
> kotlin class 默认是final的, 使用`open`修饰可以继承, `abstract`默认是open的

    open class Base(p: Int)
    class Derived(p: Int) : Base(p)

> 如果派生类有主构造函数, 那么在主构造函数中需要初始化基类; 如果没有主构造函数, 那么每个第二构造函数都需要初始化基类.
    
    class MyView : View {
        constructor(ctx: Context) : super(ctx)

        constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs)
    }

    // override
    open class Shape { // 如果没有open, 类里的open不起作用
        open val vertexCount: Int = 0 // 属性重写跟方法一样
        open fun draw() { /*...*/ } 
        fun fill() { /*...*/ } // 没有open修饰, 不能重写
    }

    // 可以在主构造函数中使用`override`
    class Circle() : Shape() {
        override var vertexCount = 4 // 可以使用var重写val, 不能反过来; 本质上val属性只有get方法, 改成var就是加上set方法
        final override fun draw() { /*...*/ } // override 默认是打开, final可以关闭, 子类不能重写该方法.
    }

> 派生类初始化过程, 在基类中使用开放属性是不正确的, 因为基类初始化里派生类还没有初始化.

    open class Base(val name: String) {

        init { println("Initializing a base class") }

        open val size: Int = 
            name.length.also { println("Initializing size in the base class: $it") }
    }

    class Derived(
        name: String,
        val lastName: String,
    ) : Base(name.replaceFirstChar { it.uppercase() }.also { println("Argument for the base class: $it") }) {

        init { println("Initializing a derived class") }

        override val size: Int =
            (super.size + lastName.length).also { println("Initializing size in the derived class: $it") }
    }

## Reference
[Classes](https://kotlinlang.org/docs/classes.html)  
